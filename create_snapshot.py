import os
import datetime

# --- Configuration ---
# Defaults to the current directory where the script is run
DEFAULT_PROJECT_ROOT = os.getcwd()
DEFAULT_OUTPUT_FILE = "project_snapshot_py.txt"

# --- Files/Folders to COMPLETELY EXCLUDE from the snapshot ---
EXCLUDED_FOLDERS_AND_FILES = [
    # Common VCS
    ".git",
    ".hg",
    ".svn",
    # IDE and editor specific (these are better off completely excluded)
    ".idea",
    "*.iml", ".ipr", ".iws", # IntelliJ specific
    ".vscode", # VS Code specific (unless launch/tasks.json are desired, then be more granular)
    # Flutter/Dart specific build/tooling
    ".dart_tool",
    "build",
    # iOS specific build artifacts and large/generated folders
    "ios/Pods",
    "ios/.symlinks",
    "ios/Flutter/App.framework",
    "ios/Flutter/Flutter.framework",
    "ios/Flutter/engine",
    "ios/Flutter/ephemeral", # Contains generated debug helpers
    "ios/DerivedData",
    "ios/Runner/Assets.xcassets", # Often contains many images, better to exclude folder
    "ios/Runner.xcworkspace/xcuserdata", # User-specific Xcode data
    # Android specific build artifacts and large/generated folders
    "android/.gradle",
    "android/app/build",
    "android/build",
    "android/key.properties", # Sensitive
    "android/local.properties", # Local paths
    "android/gradlew", # Executable
    "android/gradlew.bat", # Executable
    "android/gradle/wrapper/gradle-wrapper.jar", # Binary
    # Other platform specific build artifacts
    "linux/flutter/ephemeral",
    "macos/flutter/ephemeral",
    "windows/flutter/ephemeral",
    "web/build",
    # Common generated or lock files
    "pubspec.lock",
    # Firebase Functions specific exclusions (NEW ADDITIONS)
    "functions/node_modules", # Node.js dependencies (very large)
    "functions/lib",          # Compiled JavaScript output from TypeScript (if present)
    # Specific files to exclude (DEFAULT_OUTPUT_FILE is added dynamically later to avoid self-inclusion)
]

# --- File extensions to COMPLETELY EXCLUDE (mostly binary, assets, or irrelevant for code review) ---
# Note: Assets like images/fonts specified in pubspec.yaml are still part of the project,
# but their binary content is usually not needed in a code snapshot.
EXCLUDED_EXTENSIONS = [
    # Common binary/asset types
    ".png", ".jpg", ".jpeg", ".gif", ".svg", ".webp", # Images
    ".ico",
    ".mp3", ".wav", ".ogg", ".m4a",                  # Audio
    ".mp4", ".mov", ".avi", ".webm",                 # Video
    ".ttf", ".otf", ".woff", ".woff2",                # Fonts
    ".zip", ".gz", ".tar", ".rar", ".7z",             # Archives
    ".a", ".so", ".dll", ".exe", ".obj", ".o", ".dylib", # Compiled binaries
    ".jar", ".class",
    ".keystore", ".jks",                             # Keystores
    ".log",
    ".DS_Store",                                     # macOS
    ".swp", ".swo",                                  # Vim swap files
]

# --- Files/Patterns for which to OMIT CONTENT (file will be listed, but content replaced with a placeholder) ---
# These are typically generated files that are part of the project structure but whose exact content
# is less critical for understanding the app's primary logic and can be regenerated.
CONTENT_OMITTED_PATTERNS = [
    ".flutter-plugins-dependencies", # Generated by Flutter, tracks native plugin paths
    "lib/firebase_options.dart",    # Generated by FlutterFire CLI
    # Generated plugin registrants (Java, Obj-C/Swift)
    "android/app/src/main/java/io/flutter/plugins/GeneratedPluginRegistrant.java",
    "ios/Runner/GeneratedPluginRegistrant.h",
    "ios/Runner/GeneratedPluginRegistrant.m",
    # Generated Xcode config file by Flutter
    "ios/Flutter/Generated.xcconfig",
    # If you want to list this script but omit its content, and it's NOT the output file:
    # "create_snapshot.py", # Or use __file__ if the script is in the project root
]

def should_completely_exclude(path, project_root, dynamic_exclusions_set):
    """Checks if a given path (file or directory) should be completely excluded from the snapshot."""
    relative_path = os.path.relpath(path, project_root).replace(os.sep, '/')

    # Check against dynamically added exclusions (like the output file itself)
    if relative_path in dynamic_exclusions_set:
        return True

    # Check against pre-defined excluded folders and specific files
    for excluded_item in EXCLUDED_FOLDERS_AND_FILES:
        if excluded_item.startswith("*."): # Glob pattern for extensions like *.iml
            if relative_path.endswith(excluded_item[1:]):
                return True
        elif relative_path.startswith(excluded_item + '/') or relative_path == excluded_item:
            return True

    # If it's a file, check its extension
    if os.path.isfile(path):
        _, ext = os.path.splitext(path)
        if ext.lower() in EXCLUDED_EXTENSIONS:
            return True
    return False

def should_omit_content(relative_path, dynamic_content_omit_set):
    """Checks if the content of a given file (by relative path) should be omitted."""
    # Check against dynamically added content omission (like the script itself)
    if relative_path in dynamic_content_omit_set:
        return True
        
    for pattern in CONTENT_OMITTED_PATTERNS:
        if relative_path == pattern:
            return True
    return False

def create_project_snapshot(project_root=DEFAULT_PROJECT_ROOT, output_file_name=DEFAULT_OUTPUT_FILE):
    """
    Walks through the project directory, collects relevant file contents,
    and writes them to a single output file.
    """
    output_file_path = os.path.join(project_root, output_file_name)

    # Dynamically determine exclusions for the current run
    dynamic_exclusions_set = {output_file_name}
    dynamic_content_omit_set = set(CONTENT_OMITTED_PATTERNS) # Start with base patterns

    current_script_relative_path = os.path.relpath(os.path.abspath(__file__), project_root).replace(os.sep, '/')
    if current_script_relative_path == output_file_name:
        # If the script itself is the output file, it's already in dynamic_exclusions_set
        pass
    else:
        # If the script is run from within the project root and is not the output file,
        # add it to content omitted so its presence is noted without dumping its full source.
        if current_script_relative_path.startswith(os.path.relpath(project_root, project_root)) and \
           not current_script_relative_path.startswith('..'): # Ensure it's truly inside project_root
            dynamic_content_omit_set.add(current_script_relative_path)


    print(f"Project Root: {project_root}")
    print(f"Output File: {output_file_path}")

    with open(output_file_path, "w", encoding="utf-8", errors="ignore") as outfile:
        outfile.write("Flutter Project Snapshot (Python Script)\n")
        outfile.write(f"Project Root: {project_root}\n")
        outfile.write(f"Snapshot created on: {datetime.datetime.now().isoformat()}\n")
        outfile.write("=" * 80 + "\n\n")

        for root, dirs, files in os.walk(project_root, topdown=True):
            # Filter directories to prevent descending into them
            # IMPORTANT: Modifying 'dirs' in-place affects os.walk behavior
            dirs[:] = [d for d in dirs if not should_completely_exclude(os.path.join(root, d), project_root, dynamic_exclusions_set)]

            for filename in files:
                filepath = os.path.join(root, filename)
                relative_filepath = os.path.relpath(filepath, project_root).replace(os.sep, '/')

                if should_completely_exclude(filepath, project_root, dynamic_exclusions_set):
                    print(f"Excluding: {relative_filepath}")
                    continue

                print(f"Processing: {relative_filepath}")
                outfile.write(f"=== FILE: {relative_filepath} ===\n")
                outfile.write("-" * 50 + "\n")

                if should_omit_content(relative_filepath, dynamic_content_omit_set):
                    outfile.write("[Content Omitted - Generated/Tooling File]\n")
                else:
                    try:
                        with open(filepath, "r", encoding="utf-8", errors="ignore") as infile:
                            outfile.write(infile.read())
                    except Exception as e:
                        outfile.write(f"[Error reading file: {e}]\n")
                
                outfile.write("\n" + "-" * 50 + "\n")
                outfile.write(f"=== END OF FILE: {relative_filepath} ===\n\n\n")

        outfile.write("=" * 80 + "\n")
        outfile.write("Snapshot Complete.\n")

    print(f"Project snapshot created: {output_file_path}")

if __name__ == "__main__":
    # Example of running on a specific project path:
    # current_project_path = r"C:\Users\levndays\Desktop\muscle_up"
    # create_project_snapshot(project_root=current_project_path, output_file_name="muscle_up_snapshot.txt")
    
    # By default, uses the directory where the script is run as the project root
    create_project_snapshot()