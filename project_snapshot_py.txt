Flutter Project Snapshot (Python Script)
Project Root: C:\Users\levndays\Desktop\muscle_up
Snapshot created on: 2025-05-27T02:57:00.853011
================================================================================

=== FILE: .flutter-plugins-dependencies ===
--------------------------------------------------
{"info":"This is a generated file; do not edit or check into version control.","plugins":{"ios":[{"name":"cloud_firestore","path":"C:\\\\Users\\\\levndays\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\cloud_firestore-5.6.8\\\\","native_build":true,"dependencies":["firebase_core"],"dev_dependency":false},{"name":"firebase_auth","path":"C:\\\\Users\\\\levndays\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\firebase_auth-5.5.4\\\\","native_build":true,"dependencies":["firebase_core"],"dev_dependency":false},{"name":"firebase_core","path":"C:\\\\Users\\\\levndays\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\firebase_core-3.13.1\\\\","native_build":true,"dependencies":[],"dev_dependency":false},{"name":"google_sign_in_ios","path":"C:\\\\Users\\\\levndays\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\google_sign_in_ios-5.9.0\\\\","shared_darwin_source":true,"native_build":true,"dependencies":[],"dev_dependency":false}],"android":[{"name":"cloud_firestore","path":"C:\\\\Users\\\\levndays\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\cloud_firestore-5.6.8\\\\","native_build":true,"dependencies":["firebase_core"],"dev_dependency":false},{"name":"firebase_auth","path":"C:\\\\Users\\\\levndays\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\firebase_auth-5.5.4\\\\","native_build":true,"dependencies":["firebase_core"],"dev_dependency":false},{"name":"firebase_core","path":"C:\\\\Users\\\\levndays\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\firebase_core-3.13.1\\\\","native_build":true,"dependencies":[],"dev_dependency":false},{"name":"google_sign_in_android","path":"C:\\\\Users\\\\levndays\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\google_sign_in_android-6.2.1\\\\","native_build":true,"dependencies":[],"dev_dependency":false}],"macos":[{"name":"cloud_firestore","path":"C:\\\\Users\\\\levndays\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\cloud_firestore-5.6.8\\\\","native_build":true,"dependencies":["firebase_core"],"dev_dependency":false},{"name":"firebase_auth","path":"C:\\\\Users\\\\levndays\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\firebase_auth-5.5.4\\\\","native_build":true,"dependencies":["firebase_core"],"dev_dependency":false},{"name":"firebase_core","path":"C:\\\\Users\\\\levndays\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\firebase_core-3.13.1\\\\","native_build":true,"dependencies":[],"dev_dependency":false},{"name":"google_sign_in_ios","path":"C:\\\\Users\\\\levndays\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\google_sign_in_ios-5.9.0\\\\","shared_darwin_source":true,"native_build":true,"dependencies":[],"dev_dependency":false}],"linux":[],"windows":[{"name":"cloud_firestore","path":"C:\\\\Users\\\\levndays\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\cloud_firestore-5.6.8\\\\","native_build":true,"dependencies":["firebase_core"],"dev_dependency":false},{"name":"firebase_auth","path":"C:\\\\Users\\\\levndays\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\firebase_auth-5.5.4\\\\","native_build":true,"dependencies":["firebase_core"],"dev_dependency":false},{"name":"firebase_core","path":"C:\\\\Users\\\\levndays\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\firebase_core-3.13.1\\\\","native_build":true,"dependencies":[],"dev_dependency":false}],"web":[{"name":"cloud_firestore_web","path":"C:\\\\Users\\\\levndays\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\cloud_firestore_web-4.4.8\\\\","dependencies":["firebase_core_web"],"dev_dependency":false},{"name":"firebase_auth_web","path":"C:\\\\Users\\\\levndays\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\firebase_auth_web-5.14.3\\\\","dependencies":["firebase_core_web"],"dev_dependency":false},{"name":"firebase_core_web","path":"C:\\\\Users\\\\levndays\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\firebase_core_web-2.23.0\\\\","dependencies":[],"dev_dependency":false},{"name":"google_sign_in_web","path":"C:\\\\Users\\\\levndays\\\\AppData\\\\Local\\\\Pub\\\\Cache\\\\hosted\\\\pub.dev\\\\google_sign_in_web-0.12.4+4\\\\","dependencies":[],"dev_dependency":false}]},"dependencyGraph":[{"name":"cloud_firestore","dependencies":["cloud_firestore_web","firebase_core"]},{"name":"cloud_firestore_web","dependencies":["firebase_core","firebase_core_web"]},{"name":"firebase_auth","dependencies":["firebase_auth_web","firebase_core"]},{"name":"firebase_auth_web","dependencies":["firebase_core","firebase_core_web"]},{"name":"firebase_core","dependencies":["firebase_core_web"]},{"name":"firebase_core_web","dependencies":[]},{"name":"google_sign_in","dependencies":["google_sign_in_android","google_sign_in_ios","google_sign_in_web"]},{"name":"google_sign_in_android","dependencies":[]},{"name":"google_sign_in_ios","dependencies":[]},{"name":"google_sign_in_web","dependencies":[]}],"date_created":"2025-05-27 01:56:50.317841","version":"3.32.0","swift_package_manager_enabled":{"ios":false,"macos":false}}
--------------------------------------------------
=== END OF FILE: .flutter-plugins-dependencies ===


=== FILE: .gitignore ===
--------------------------------------------------
# Miscellaneous
*.class
*.log
*.pyc
*.swp
.DS_Store
.atom/
.build/
.buildlog/
.history
.svn/
.swiftpm/
migrate_working_dir/

# IntelliJ related
*.iml
*.ipr
*.iws
.idea/

# The .vscode folder contains launch configuration and tasks you configure in
# VS Code which you may wish to be included in version control, so this line
# is commented out by default.
#.vscode/

# Flutter/Dart/Pub related
**/doc/api/
**/ios/Flutter/.last_build_id
.dart_tool/
.flutter-plugins
.flutter-plugins-dependencies
.pub-cache/
.pub/
/build/

# Symbolication related
app.*.symbols

# Obfuscation related
app.*.map.json

# Android Studio will place build artifacts here
/android/app/debug
/android/app/profile
/android/app/release

--------------------------------------------------
=== END OF FILE: .gitignore ===


=== FILE: .metadata ===
--------------------------------------------------
# This file tracks properties of this Flutter project.
# Used by Flutter tool to assess capabilities and perform upgrades etc.
#
# This file should be version controlled and should not be manually edited.

version:
  revision: "be698c48a6750c8cb8e61c740ca9991bb947aba2"
  channel: "stable"

project_type: app

# Tracks metadata for the flutter migrate command
migration:
  platforms:
    - platform: root
      create_revision: be698c48a6750c8cb8e61c740ca9991bb947aba2
      base_revision: be698c48a6750c8cb8e61c740ca9991bb947aba2
    - platform: android
      create_revision: be698c48a6750c8cb8e61c740ca9991bb947aba2
      base_revision: be698c48a6750c8cb8e61c740ca9991bb947aba2
    - platform: ios
      create_revision: be698c48a6750c8cb8e61c740ca9991bb947aba2
      base_revision: be698c48a6750c8cb8e61c740ca9991bb947aba2
    - platform: linux
      create_revision: be698c48a6750c8cb8e61c740ca9991bb947aba2
      base_revision: be698c48a6750c8cb8e61c740ca9991bb947aba2
    - platform: macos
      create_revision: be698c48a6750c8cb8e61c740ca9991bb947aba2
      base_revision: be698c48a6750c8cb8e61c740ca9991bb947aba2
    - platform: web
      create_revision: be698c48a6750c8cb8e61c740ca9991bb947aba2
      base_revision: be698c48a6750c8cb8e61c740ca9991bb947aba2
    - platform: windows
      create_revision: be698c48a6750c8cb8e61c740ca9991bb947aba2
      base_revision: be698c48a6750c8cb8e61c740ca9991bb947aba2

  # User provided section

  # List of Local paths (relative to this file) that should be
  # ignored by the migrate tool.
  #
  # Files that are not part of the templates will be ignored by default.
  unmanaged_files:
    - 'lib/main.dart'
    - 'ios/Runner.xcodeproj/project.pbxproj'

--------------------------------------------------
=== END OF FILE: .metadata ===


=== FILE: analysis_options.yaml ===
--------------------------------------------------
include: package:flutter_lints/flutter.yaml

--------------------------------------------------
=== END OF FILE: analysis_options.yaml ===


=== FILE: create_snapshot.py ===
--------------------------------------------------
import os
import datetime

# --- Configuration ---
# Defaults to the current directory where the script is run
DEFAULT_PROJECT_ROOT = os.getcwd()
DEFAULT_OUTPUT_FILE = "project_snapshot_py.txt"

EXCLUDED_FOLDERS_AND_FILES = [
    # Common VCS
    ".git",
    ".hg",
    ".svn",
    # IDE and editor specific
    ".idea",
    ".vscode",
    # Flutter/Dart specific build/tooling
    ".dart_tool",
    "build",
    # iOS specific
    "ios/Pods",
    "ios/.symlinks",
    "ios/Flutter/App.framework",
    "ios/Flutter/Flutter.framework",
    "ios/Flutter/engine",
    "ios/DerivedData",
    "ios/Runner/Assets.xcassets", # Often contains many images
    "ios/Runner.xcworkspace/xcuserdata",
    # Android specific
    "android/.gradle",
    "android/.idea",
    "android/app/build",
    "android/build",
    "android/key.properties", # Sensitive
    "android/local.properties", # Local paths
    "android/gradlew", # Executable
    "android/gradlew.bat", # Executable
    "android/gradle/wrapper/gradle-wrapper.jar", # Binary
    # Other platform specific build artifacts
    "linux/flutter/ephemeral",
    "macos/flutter/ephemeral",
    "windows/flutter/ephemeral",
    "web/build",
    # Common generated or lock files
    "pubspec.lock",
    "*.iml", ".ipr", ".iws", # IntelliJ
    # Specific files to exclude
    DEFAULT_OUTPUT_FILE # Don't include the output file itself if run multiple times
]

# Exclude file extensions (mostly binary, assets, or irrelevant for code review)
EXCLUDED_EXTENSIONS = [
    # Common binary/asset types
    ".png", ".jpg", ".jpeg", ".gif", ".svg", ".webp", # Images
    ".ico",
    ".mp3", ".wav", ".ogg", ".m4a",                  # Audio
    ".mp4", ".mov", ".avi", ".webm",                 # Video
    ".ttf", ".otf", ".woff", ".woff2",                # Fonts
    ".zip", ".gz", ".tar", ".rar", ".7z",             # Archives
    ".a", ".so", ".dll", ".exe", ".obj", ".o", ".dylib", # Compiled binaries
    ".jar", ".class",
    ".keystore", ".jks",                             # Keystores
    ".log",
    ".DS_Store",                                     # macOS
    ".swp", ".swo",                                  # Vim swap files
    # Consider if you want to exclude assets folder content based on extensions
    # or exclude the entire 'assets/' folder by adding it to EXCLUDED_FOLDERS_AND_FILES
]

def should_exclude(path, project_root):
    """Checks if a given path (file or directory) should be excluded."""
    relative_path = os.path.relpath(path, project_root).replace(os.sep, '/')

    # 1. Check against excluded folders and specific files
    for excluded_item in EXCLUDED_FOLDERS_AND_FILES:
        if relative_path.startswith(excluded_item + '/') or relative_path == excluded_item:
            return True

    # 2. If it's a file, check its extension
    if os.path.isfile(path):
        _, ext = os.path.splitext(path)
        if ext.lower() in EXCLUDED_EXTENSIONS:
            return True
    return False

def create_project_snapshot(project_root=DEFAULT_PROJECT_ROOT, output_file_name=DEFAULT_OUTPUT_FILE):
    """
    Walks through the project directory, collects relevant file contents,
    and writes them to a single output file.
    """
    output_file_path = os.path.join(project_root, output_file_name)
    # Add the dynamic output file name to excluded items to prevent self-inclusion
    if output_file_name not in EXCLUDED_FOLDERS_AND_FILES:
        EXCLUDED_FOLDERS_AND_FILES.append(output_file_name)


    print(f"Project Root: {project_root}")
    print(f"Output File: {output_file_path}")

    with open(output_file_path, "w", encoding="utf-8", errors="ignore") as outfile:
        outfile.write("Flutter Project Snapshot (Python Script)\n")
        outfile.write(f"Project Root: {project_root}\n")
        outfile.write(f"Snapshot created on: {datetime.datetime.now().isoformat()}\n")
        outfile.write("=" * 80 + "\n\n")

        for root, dirs, files in os.walk(project_root, topdown=True):
            # --- Directory Exclusion ---
            # Modify dirs in-place to prevent os.walk from traversing into them
            dirs[:] = [d for d in dirs if not should_exclude(os.path.join(root, d), project_root)]

            for filename in files:
                filepath = os.path.join(root, filename)
                if should_exclude(filepath, project_root):
                    continue

                relative_filepath = os.path.relpath(filepath, project_root).replace(os.sep, '/')
                print(f"Processing: {relative_filepath}")

                outfile.write(f"=== FILE: {relative_filepath} ===\n")
                outfile.write("-" * 50 + "\n")
                try:
                    with open(filepath, "r", encoding="utf-8", errors="ignore") as infile:
                        outfile.write(infile.read())
                except Exception as e:
                    outfile.write(f"[Error reading file: {e}]\n")
                outfile.write("\n" + "-" * 50 + "\n")
                outfile.write(f"=== END OF FILE: {relative_filepath} ===\n\n\n")

        outfile.write("=" * 80 + "\n")
        outfile.write("Snapshot Complete.\n")

    print(f"Project snapshot created: {output_file_path}")

if __name__ == "__main__":
    # You can customize the project root and output file name here if needed
    # For example, if your script is not in the project root:
    # current_project_path = r"C:\Users\levndays\Desktop\muscle_up"
    # create_project_snapshot(project_root=current_project_path)

    # By default, uses the directory where the script is run as the project root
    create_project_snapshot()
--------------------------------------------------
=== END OF FILE: create_snapshot.py ===


=== FILE: firebase.json ===
--------------------------------------------------
{"flutter":{"platforms":{"android":{"default":{"projectId":"muscle-up-8c275","appId":"1:1012783717502:android:2f7ce9326b23c730938c2f","fileOutput":"android/app/google-services.json"}},"dart":{"lib/firebase_options.dart":{"projectId":"muscle-up-8c275","configurations":{"android":"1:1012783717502:android:2f7ce9326b23c730938c2f","ios":"1:1012783717502:ios:debb2939085adc3f938c2f","macos":"1:1012783717502:ios:debb2939085adc3f938c2f","web":"1:1012783717502:web:89f5605ac9ecd155938c2f","windows":"1:1012783717502:web:a6ef83f4982ba06e938c2f"}}}}}}
--------------------------------------------------
=== END OF FILE: firebase.json ===


=== FILE: muscle_up.iml ===
--------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/lib" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/test" isTestSource="true" />
      <excludeFolder url="file://$MODULE_DIR$/.dart_tool" />
      <excludeFolder url="file://$MODULE_DIR$/.idea" />
      <excludeFolder url="file://$MODULE_DIR$/build" />
    </content>
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="Dart SDK" level="project" />
    <orderEntry type="library" name="Flutter Plugins" level="project" />
    <orderEntry type="library" name="Dart Packages" level="project" />
  </component>
</module>

--------------------------------------------------
=== END OF FILE: muscle_up.iml ===


=== FILE: pubspec.yaml ===
--------------------------------------------------
name: muscle_up
description: "A new Flutter project."
publish_to: 'none' # Remove this line if you want to publish to pub.dev
version: 0.1.0 # Або твоя поточна версія

environment:
  sdk: ^3.8.0 # Або твоя поточна версія Dart SDK

dependencies:
  flutter:
    sdk: flutter
  firebase_core: ^3.13.1 # Або остання версія
  firebase_auth: ^5.5.4 # Або остання версія
  google_sign_in: ^6.2.1 # Або остання версія
  cloud_firestore: ^5.6.8 # Або остання версія
  animated_background: ^2.0.0

  flutter_bloc: ^9.1.1  
  equatable: ^2.0.5

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^5.0.0 # Або остання версія

flutter:
  uses-material-design: true

  assets:
    - assets/images/ # Для логотипу Google та інших зображень
    # - assets/some_other_folder/ # Якщо є інші асети

  fonts:
    - family: Inter
      fonts:
        - asset: assets/fonts/Inter_18pt-Regular.ttf
        - asset: assets/fonts/Inter_18pt-Italic.ttf
          style: italic
        - asset: assets/fonts/Inter_18pt-Light.ttf
          weight: 300
        - asset: assets/fonts/Inter_18pt-Medium.ttf
          weight: 500
        - asset: assets/fonts/Inter_18pt-SemiBold.ttf
          weight: 600
        - asset: assets/fonts/Inter_18pt-Bold.ttf
          weight: 700
        - asset: assets/fonts/Inter_18pt-ExtraBold.ttf
          weight: 800
        - asset: assets/fonts/Inter_18pt-Black.ttf
          weight: 900
    # Можеш додати інші сімейства шрифтів тут
--------------------------------------------------
=== END OF FILE: pubspec.yaml ===


=== FILE: README.md ===
--------------------------------------------------
# MuscleUP: Фітнес-застосунок для справжніх атлетів

**Motto:** Level Up Your Lifts, Connect Your Crew, Achieve Your Goals. Build Your Strength, Together.

## 1. Вступ

**MuscleUP** – це мобільний фітнес-застосунок, розроблений для розв'язання поширеної проблеми відтоку користувачів у фітнес-додатках. Наша мета – сприяти довгостроковій залученості шляхом створення високомотивуючого, соціально інтерактивного та гейміфікованого середовища. MuscleUP дає змогу користувачам ретельно відстежувати свої тренування, встановлювати та досягати персоналізованих фітнес-цілей, ділитися своїм шляхом та черпати натхнення від спільноти, що підтримує.

Цей документ описує поточну реалізацію бізнес-логіки, архітектуру програмного забезпечення та дизайн бекенду з акцентом на модульність, масштабованість та легкість супроводу. Проєкт розробляється як дипломна робота і є основою для майбутнього повноцінного продукту, як описано в [MuscleUP: Application Design Document (Version 2.0 - Product Focused)](./MuscleUP_Application_Design_Document_v2.txt) (припустимо, що цей файл лежить поруч).

**Поточний стан:** Реалізовано ядро автентифікації (Email/Password, Google Sign-In), створення профілю користувача в Firestore, а також базовий функціонал для перегляду бібліотеки вправ та створення/управління користувацькими тренувальними рутинами.

## 2. Ключові Архітектурні Принципи

Дизайн MuscleUP керується наступними принципами (детальніше в дизайн-документі):

*   **Модульність:** Функції розробляються як слабозв'язані модулі.
*   **Масштабованість:** Фронтенд та бекенд розраховані на зростання.
*   **Легкість супроводу:** Чітке розділення відповідальностей, послідовні патерни кодування.
*   **Розширюваність:** Система спроєктована для легкого додавання нових функцій.
*   **Рішення на основі даних:** Дизайн сприяє збору аналітики (в майбутньому).

## 3. Технологічний Стек

*   **Фронтенд:**
    *   **Framework:** Flutter (версія SDK, як у `pubspec.yaml`)
    *   **Мова:** Dart (версія SDK, як у `pubspec.yaml`)
    *   **Управління станом:** Flutter BLoC/Cubit (використовується в реалізованих модулях `exercise_explorer` та `routines`)
    *   **Навігація:** Стандартна Flutter навігація (в майбутньому планується перехід на GoRouter або AutoRoute).
    *   **Залежності (ключові):**
        *   `firebase_core`: Базовий пакет Firebase.
        *   `firebase_auth`: Автентифікація Firebase.
        *   `google_sign_in`: Автентифікація через Google.
        *   `cloud_firestore`: База даних Firestore.
        *   `flutter_bloc`: Для реалізації BLoC/Cubit.
        *   `equatable`: Для порівняння об'єктів у станах BLoC/Cubit.
        *   `animated_background`: Для анімації фону на сторінці логіну.
        *   `flutter_lints`: Для аналізу коду.
*   **Бекенд:**
    *   **Firebase:**
        *   **Authentication:** Для управління користувачами.
        *   **Cloud Firestore:** NoSQL база даних для зберігання даних застосунку.
        *   **Firebase Storage:** (Планується) для зберігання медіафайлів (аватари, докази рекордів).
        *   **Cloud Functions:** (Планується) для серверної логіки, автоматизації, тригерів.

## 4. Файлова Структура Проєкту (`lib/`)

Проєкт дотримується модульної, feature-first архітектури, що сприяє розділенню відповідальностей та масштабованості.


muscle_up/
├── lib/
│ ├── main.dart # Точка входу в застосунок, ініціалізація Firebase
│ ├── auth_gate.dart # Віджет для управління станом автентифікації (перенаправлення)
│ ├── firebase_options.dart # Конфігураційні дані Firebase (згенеровано FlutterFire CLI)
│ │
│ ├── home_page.dart # Тимчасова домашня сторінка після логіну
│ ├── login_page.dart # UI та логіка для екрану входу/реєстрації
│ │
│ ├── app_config/ # (Планується) Базове налаштування застосунку
│ │ ├── app_widget.dart # (Планується) Кореневий MaterialApp
│ │ ├── di_container.dart # (Планується) Налаштування Dependency Injection (напр. GetIt)
│ │ ├── navigation/ # (Планується) Централізована навігація
│ │ └── theme/ # (Планується) Глобальні теми, кольори, шрифти
│ │
│ ├── core/ # Спільна бізнес-логіка, моделі, інтерфейси
│ │ ├── common/ # (Планується) Базові класи, винятки, типи результатів
│ │ ├── domain/
│ │ │ ├── entities/ # Об'єкти предметної області (POJO/PODO)
│ │ │ │ ├── predefined_exercise.dart # Модель для стандартизованої вправи
│ │ │ │ └── routine.dart # Моделі UserRoutine та RoutineExercise
│ │ │ └── repositories/ # Абстрактні інтерфейси для операцій з даними
│ │ │ ├── predefined_exercise_repository.dart # Інтерфейс для predefinedExercises
│ │ │ └── routine_repository.dart # Інтерфейс для userRoutines
│ │ └── enums/ # (Планується) Глобальні enum'и
│ │
│ ├── features/ # Кожен модуль фічі
│ │ ├── auth/ # (Неявно реалізовано в login_page.dart, auth_gate.dart)
│ │ │ ├── presentation/
│ │ │ │ ├── screens/ # login_page.dart, home_page.dart (поточна)
│ │ │
│ │ ├── exercise_explorer/ # Модуль для перегляду бібліотеки вправ
│ │ │ ├── data/
│ │ │ │ └── repositories/
│ │ │ │ └── predefined_exercise_repository_impl.dart # Реалізація репозиторію
│ │ │ ├── presentation/
│ │ │ │ ├── cubit/
│ │ │ │ │ ├── exercise_explorer_cubit.dart # Логіка стану для списку вправ
│ │ │ │ │ └── exercise_explorer_state.dart # Стани для ExerciseExplorerCubit
│ │ │ │ ├── screens/
│ │ │ │ │ └── exercise_explorer_screen.dart # UI для відображення списку вправ
│ │ │ │ └── widgets/
│ │ │ │ └── exercise_list_item.dart # Віджет для одного елемента списку вправ
│ │ │
│ │ ├── routines/ # Модуль для управління користувацькими рутинами
│ │ │ ├── data/
│ │ │ │ └── repositories/
│ │ │ │ └── routine_repository_impl.dart # Реалізація репозиторію рутин
│ │ │ ├── presentation/
│ │ │ │ ├── cubit/
│ │ │ │ │ ├── user_routines_cubit.dart # Логіка стану для списку рутин користувача
│ │ │ │ │ ├── user_routines_state.dart # Стани для UserRoutinesCubit
│ │ │ │ │ ├── manage_routine_cubit.dart # Логіка стану для створення/редагування рутини
│ │ │ │ │ └── manage_routine_state.dart # Стани для ManageRoutineCubit
│ │ │ │ ├── screens/
│ │ │ │ │ ├── user_routines_screen.dart # UI для списку рутин користувача
│ │ │ │ │ └── create_edit_routine_screen.dart # UI для створення/редагування рутини
│ │ │ │ └── widgets/
│ │ │ │ ├── routine_list_item.dart # Віджет для одного елемента списку рутин
│ │ │ │ └── add_exercise_to_routine_dialog.dart # (Планується) Діалог/екран для додавання вправ до рутини
│ │ │
│ │ ├── onboarding/ # (Планується) Модуль онбордингу
│ │ ├── dashboard/ # (Планується) Головний екран застосунку
│ │ └── ... # Інші майбутні фічі
│ │
│ ├── data_sources/ # (Планується) Спільні реалізації джерел даних
│ │ ├── firebase/
│ │ │ ├── firestore_service.dart # (Планується) Огортка для Firestore
│ │
│ └── presentation_common/ # (Планується) Спільні віджети та UI-утиліти
│ └── widgets/
│
├── assets/
│ ├── images/
│ │ └── google_logo.png # Логотип Google для кнопки
│ └── fonts/
│ └── Inter_...ttf # Файли шрифтів Inter
│
├── android/ # Специфічний код та конфігурація для Android
├── ios/ # Специфічний код та конфігурація для iOS
├── web/ # Специфічний код та конфігурація для Web
└── ... # Інші файли та папки проєкту

## 5. Детальний Опис Ключових Компонентів та Логіки

### 5.1. Автентифікація та Управління Користувачем

*   **`main.dart`**:
    *   **Призначення**: Головний файл, точка входу в застосунок.
    *   **Логіка**: Ініціалізує Firebase (`Firebase.initializeApp`) перед запуском будь-яких віджетів. Створює екземпляр `MainApp`.
*   **`MainApp` (у `main.dart`)**:
    *   **Призначення**: Кореневий віджет застосунку.
    *   **Логіка**: `StatelessWidget`, який повертає `MaterialApp`. Встановлює базову тему, глобальні стилі для полів вводу та кнопок. В якості `home` використовує `AuthGate`.
*   **`auth_gate.dart`**:
    *   **Призначення**: Керує потоком автентифікації.
    *   **Логіка**: Використовує `StreamBuilder` для прослуховування змін стану автентифікації (`FirebaseAuth.instance.authStateChanges()`).
        *   Якщо з'єднання в очікуванні (`ConnectionState.waiting`), показує `CircularProgressIndicator`.
        *   Якщо користувач автентифікований (`snapshot.hasData`), перенаправляє на `HomePage`.
        *   Якщо користувач не автентифікований, перенаправляє на `LoginPage`.
*   **`login_page.dart`**:
    *   **Призначення**: Екран для входу та реєстрації користувача.
    *   **Логіка**:
        *   Використовує `StatefulWidget` та `GlobalKey<FormState>` для валідації форм.
        *   Має контролери `_emailController` та `_passwordController`.
        *   Змінна `_isLogin` перемикає режим між входом та реєстрацією.
        *   **Анімація фону**: Використовує `AnimationController` та `AlignmentTween` для створення динамічного градієнтного фону.
        *   **`_submitForm()`**:
            *   Валідує форму.
            *   Якщо `_isLogin` = `true`, викликає `FirebaseAuth.instance.signInWithEmailAndPassword()`.
            *   Якщо `_isLogin` = `false`, викликає `FirebaseAuth.instance.createUserWithEmailAndPassword()`. Після успішної реєстрації викликає `_createInitialUserProfile()` для нового користувача.
        *   **`_signInWithGoogle()`**:
            *   Використовує плагін `google_sign_in` для отримання облікових даних Google.
            *   Створює `AuthCredential` та викликає `FirebaseAuth.instance.signInWithCredential()`.
            *   Якщо це новий користувач (`additionalUserInfo?.isNewUser`), викликає `_createInitialUserProfile()`.
        *   **`_createInitialUserProfile(User user)`**:
            *   Створює новий документ у колекції `users` Firestore з `uid` користувача як ID документа.
            *   Заповнює базові поля профілю (email, displayName, photoURL з `User` об'єкта, решту полів – значеннями за замовчуванням згідно з дизайн-документом, наприклад, `profileSetupComplete: false`).
            *   Використовує `FieldValue.serverTimestamp()` для `createdAt` та `updatedAt`.
            *   Перевіряє, чи профіль вже існує, щоб уникнути перезапису.
        *   Обробляє `FirebaseAuthException` та інші помилки, відображаючи їх у `_errorMessage`.
*   **`home_page.dart`**:
    *   **Призначення**: Поточна "заглушка" для головного екрану після успішного входу.
    *   **Логіка**: Відображає базову інформацію про користувача (email, displayName, UID) та кнопку виходу (`FirebaseAuth.instance.signOut()`).

### 5.2. Бібліотека Вправ (`exercise_explorer`)

Цей модуль відповідає за відображення списку стандартизованих вправ.

*   **`core/domain/entities/predefined_exercise.dart`**:
    *   **Призначення**: Клас-модель, що представляє одну вправу з усіма її атрибутами (назва, м'язові групи, обладнання тощо).
    *   **Логіка**: Містить конструктор, фабричний метод `fromFirestore()` для перетворення `DocumentSnapshot` з Firestore в об'єкт `PredefinedExercise`, та метод `toMap()` для перетворення об'єкта в `Map` (для запису в Firestore, якщо знадобиться).
*   **`core/domain/repositories/predefined_exercise_repository.dart`**:
    *   **Призначення**: Абстрактний клас (інтерфейс), що визначає контракт для отримання даних про вправи. Це дозволяє відокремити логіку отримання даних від конкретної реалізації (наприклад, Firestore).
    *   **Методи**: `Future<List<PredefinedExercise>> getAllExercises()`.
*   **`features/exercise_explorer/data/repositories/predefined_exercise_repository_impl.dart`**:
    *   **Призначення**: Конкретна реалізація `PredefinedExerciseRepository`, що використовує Firebase Firestore для отримання даних.
    *   **Логіка**: Метод `getAllExercises()` робить запит до колекції `predefinedExercises` у Firestore, отримує всі документи та перетворює їх на список об'єктів `PredefinedExercise` за допомогою `PredefinedExercise.fromFirestore()`. Обробляє можливі помилки.
*   **`features/exercise_explorer/presentation/cubit/exercise_explorer_state.dart`**:
    *   **Призначення**: Визначає можливі стани для `ExerciseExplorerCubit` (Initial, Loading, Loaded, Error) з використанням `Equatable` для полегшення порівняння станів.
*   **`features/exercise_explorer/presentation/cubit/exercise_explorer_cubit.dart`**:
    *   **Призначення**: Управляє станом екрану бібліотеки вправ.
    *   **Логіка**:
        *   Залежить від `PredefinedExerciseRepository`.
        *   Метод `fetchExercises()`: встановлює стан `ExerciseExplorerLoading`, викликає метод `getAllExercises()` репозиторію. При успішному отриманні даних встановлює стан `ExerciseExplorerLoaded` з отриманим списком вправ. У випадку помилки – `ExerciseExplorerError`.
*   **`features/exercise_explorer/presentation/screens/exercise_explorer_screen.dart`**:
    *   **Призначення**: UI-компонент, що відображає список вправ.
    *   **Логіка**:
        *   Використовує `BlocProvider` для створення та надання `ExerciseExplorerCubit`.
        *   Використовує `BlocBuilder` для перебудови UI залежно від поточного стану `ExerciseExplorerCubit`.
        *   Відображає `CircularProgressIndicator` у стані `Loading`, список вправ (використовуючи `ListView.builder` та `ExerciseListItem`) у стані `Loaded`, або повідомлення про помилку у стані `Error`.
*   **`features/exercise_explorer/presentation/widgets/exercise_list_item.dart`**:
    *   **Призначення**: Віджет для відображення однієї вправи у списку.
    *   **Логіка**: Приймає об'єкт `PredefinedExercise` та відображає його назву, основну м'язову групу. Має обробник `onTap` для майбутньої навігації на детальний екран вправи.

### 5.3. Користувацькі Рутини (`routines`)

Цей модуль дозволяє користувачам створювати, переглядати, редагувати та видаляти власні тренувальні рутини.

*   **`core/domain/entities/routine.dart`**:
    *   **Призначення**: Містить два класи-моделі:
        *   `RoutineExercise`: Представляє одну вправу всередині рутини користувача (посилання на `predefinedExerciseId`, кількість підходів, нотатки).
        *   `UserRoutine`: Представляє повну рутину користувача (ID, userId, назва, список `RoutineExercise`, дні тижня тощо).
    *   **Логіка**: Аналогічно `PredefinedExercise`, ці класи мають конструктори, фабричні методи `fromMap`/`fromFirestore` та методи `toMap`.
*   **`core/domain/repositories/routine_repository.dart`**:
    *   **Призначення**: Абстрактний клас (інтерфейс) для операцій CRUD (Create, Read, Update, Delete) з рутинами користувача.
    *   **Методи**: `createRoutine()`, `getUserRoutines()`, `updateRoutine()`, `deleteRoutine()`.
*   **`features/routines/data/repositories/routine_repository_impl.dart`**:
    *   **Призначення**: Конкретна реалізація `RoutineRepository` з використанням Firestore.
    *   **Логіка**:
        *   `createRoutine()`: Додає новий документ до колекції `userRoutines` Firestore, використовуючи `FieldValue.serverTimestamp()` для `createdAt` та `updatedAt`.
        *   `getUserRoutines()`: Отримує всі рутини для вказаного `userId` з колекції `userRoutines`, сортуючи їх за датою створення.
        *   `updateRoutine()`: Оновлює існуючий документ рутини в Firestore, встановлюючи `updatedAt` на `FieldValue.serverTimestamp()`.
        *   `deleteRoutine()`: Видаляє документ рутини з Firestore за його ID.
*   **Кубіти для Рутин:**
    *   **`user_routines_state.dart` / `user_routines_cubit.dart`**:
        *   **Призначення**: Управління станом списку рутин користувача.
        *   **Логіка**: `UserRoutinesCubit` завантажує список рутин через `RoutineRepository` та надає його UI через стани (Initial, Loading, Loaded, Error). Має методи для завантаження та, можливо, оновлення списку після видалення/додавання.
    *   **`manage_routine_state.dart` / `manage_routine_cubit.dart`**:
        *   **Призначення**: Управління станом процесу створення або редагування однієї рутини.
        *   **Логіка**: `ManageRoutineCubit` обробляє введення даних для нової/редагованої рутини, взаємодіє з `RoutineRepository` для збереження або оновлення. Має стани для відображення процесу (Initial, Loading, Success, Error).
*   **Екрани для Рутин:**
    *   **`features/routines/presentation/screens/user_routines_screen.dart`**:
        *   **Призначення**: Відображає список всіх рутин поточного користувача.
        *   **Логіка**: Використовує `UserRoutinesCubit`. Надає можливість перейти до створення нової рутини (`CreateEditRoutineScreen`) та опції для редагування/видалення існуючих рутин.
    *   **`features/routines/presentation/screens/create_edit_routine_screen.dart`**:
        *   **Призначення**: Форма для створення нової або редагування існуючої рутини.
        *   **Логіка**: Використовує `ManageRoutineCubit`. Містить поля для назви, опису, вибору днів тижня. Ключова частина – інтерфейс для додавання вправ до рутини:
            *   Користувач може обрати вправи з `predefinedExercises` (можна використати `ExerciseExplorerScreen` в режимі вибору або окремий діалог).
            *   Для кожної обраної вправи користувач вказує кількість підходів та, можливо, нотатки.
            *   Список обраних вправ (`List<RoutineExercise>`) динамічно відображається та редагується.
*   **Віджети для Рутин:**
    *   **`features/routines/presentation/widgets/routine_list_item.dart`**: Відображає одну рутину в списку, надає опції (наприклад, через `PopupMenuButton`) для редагування та видалення.
    *   **`features/routines/presentation/widgets/add_exercise_to_routine_dialog.dart`**: (Планується або як частина `CreateEditRoutineScreen`) UI для вибору вправ з `predefinedExercises` та вказання деталей (кількість підходів).

## 6. Структура Бекенду (Firebase)

### 6.1. Firebase Authentication

*   Використовується для реєстрації та входу користувачів (Email/Password, Google).
*   UID користувача з Firebase Auth є первинним ключем для документів у колекції `users` Firestore.

### 6.2. Cloud Firestore (База Даних)

*   **`users`**:
    *   **ID Документа**: `userId` (збігається з Firebase Auth UID).
    *   **Призначення**: Зберігає всю інформацію профілю користувача.
    *   **Ключові поля (поточна реалізація в `_createInitialUserProfile`):**
        *   `uid`: String
        *   `email`: String
        *   `displayName`: String?
        *   `profilePictureUrl`: String?
        *   `username`: String? (поки `null`)
        *   `xp`: Number (default: 0)
        *   `level`: Number (default: 1)
        *   `currentStreak`: Number (default: 0)
        *   `longestStreak`: Number (default: 0)
        *   `lastWorkoutTimestamp`: Timestamp? (default: `null`)
        *   `scheduledWorkoutDays`: List<String> (default: `[]`)
        *   `preferredUnits`: String (default: 'kg')
        *   `profileSetupComplete`: Boolean (default: `false`)
        *   `createdAt`: Timestamp
        *   `updatedAt`: Timestamp
        *   Інші поля з дизайн-документа будуть додаватися поступово.
*   **`predefinedExercises`**:
    *   **ID Документа**: Автогенерований або осмислений ID вправи.
    *   **Призначення**: Зберігає стандартизовану бібліотеку вправ, керовану адміністратором.
    *   **Поля**: `name`, `normalizedName`, `primaryMuscleGroup`, `secondaryMuscleGroups`, `equipmentNeeded`, `description`, `videoDemonstrationUrl`, `difficultyLevel`, `tags`.
*   **`userRoutines`**:
    *   **ID Документа**: Автогенерований ID рутини.
    *   **Призначення**: Зберігає тренувальні рутини, створені користувачами.
    *   **Поля**: `userId`, `name`, `description`, `exercises` (список `Map`, що містить `predefinedExerciseId`, `exerciseNameSnapshot`, `numberOfSets`, `notes`), `scheduledDays`, `isPublic`, `createdAt`, `updatedAt`. Інші поля (рейтинг, копії) для майбутніх соціальних функцій.

### 6.3. Firebase Storage (Планується)

*   `profile_pictures/{userId}/<filename>`: Для зберігання аватарів користувачів.
*   Інші шляхи для медіа, пов'язаного з постами та доказами рекордів (як у дизайн-документі).

### 6.4. Firebase Cloud Functions (Планується)

Хоча ще не реалізовані, їх роль буде критичною для:

*   **Автоматичних обчислень**: Наприклад, розрахунок тренувального об'єму після збереження тренування.
*   **Тригерів**: Наприклад, нарахування XP за виконання рутини, оновлення стріків.
*   **Підтримки цілісності даних**: Наприклад, оновлення денормалізованих полів.
*   **Запланованих завдань**: Наприклад, генерація лідербордів, надсилання нагадувань.
*   **Push-сповіщень**.

## 7. Налаштування та Запуск Проєкту

1.  **Передумови**:
    *   Встановлений Flutter SDK (версія, вказана у `pubspec.yaml` або новіша).
    *   Налаштоване середовище розробки (Android Studio, VS Code з плагінами Flutter/Dart).
    *   Firebase CLI встановлено та налаштовано.
2.  **Клонування Репозиторію** (якщо проєкт у Git):
    ```bash
    git clone <URL_РЕПОЗИТОРІЮ>
    cd muscle_up
    ```
3.  **Налаштування Firebase**:
    *   Переконайся, що в корені проєкту є файл `firebase.json`.
    *   Для Android: файл `android/app/google-services.json` повинен бути завантажений з твого Firebase проєкту.
    *   Для iOS: файл `ios/Runner/GoogleService-Info.plist` (якщо використовується) повинен бути завантажений та доданий до Xcode проєкту.
    *   Файл `lib/firebase_options.dart` повинен бути актуальним (згенерований через `flutterfire configure`).
4.  **Налаштування Google Sign-In**:
    *   **Android**:
        *   Переконайся, що SHA-1 відбиток твого debug та release ключів додано до налаштувань Android-застосунку в Firebase Console.
        *   `google-services.json` повинен містити `client_id` типу 3 (Web application) для Google Sign-In.
    *   **iOS**: (Якщо планується)
        *   Додай URL Scheme до `Info.plist` (зазвичай REVERSED_CLIENT_ID з `GoogleService-Info.plist`).
5.  **Встановлення Залежностей**:
    ```bash
    flutter pub get
    ```
6.  **Запуск Застосунку**:
    *   Обери цільовий пристрій (емулятор або фізичний пристрій).
    *   Виконай:
        ```bash
        flutter run
        ```

## 8. Подальші Кроки та Розвиток (Згідно з Дизайн-Документом)

Поточна реалізація закладає фундамент. Наступні кроки включатимуть:

*   **Логування Тренувань (`userWorkouts`)**: Детальне логування сетів, повторень, ваги, RPE.
*   **Дашборд (`HomePage` -> `DashboardScreen`)**: Відображення статистики, прогресу.
*   **Гейміфікація**: Детальна система XP, рівнів, досягнень.
*   **Соціальні Функції**: Стрічка активності, підписки, публічні рекорди.
*   **Цілі**: Створення та відстеження персоналізованих цілей.
*   **Розширення UI/UX**: Покращення дизайну, онбординг.
*   **Реалізація Cloud Functions** для автоматизації та серверної логіки.
*   **Тестування**: Написання unit, widget та integration тестів.

Цей README буде оновлюватися в міру розвитку проєкту.

--------------------------------------------------
=== END OF FILE: README.md ===


=== FILE: android/.gitignore ===
--------------------------------------------------
gradle-wrapper.jar
/.gradle
/captures/
/gradlew
/gradlew.bat
/local.properties
GeneratedPluginRegistrant.java
.cxx/

# Remember to never publicly share your keystore.
# See https://flutter.dev/to/reference-keystore
key.properties
**/*.keystore
**/*.jks

--------------------------------------------------
=== END OF FILE: android/.gitignore ===


=== FILE: android/build.gradle.kts ===
--------------------------------------------------
allprojects {
    repositories {
        google()
        mavenCentral()
    }
}

val newBuildDir: Directory = rootProject.layout.buildDirectory.dir("../../build").get()
rootProject.layout.buildDirectory.value(newBuildDir)

subprojects {
    val newSubprojectBuildDir: Directory = newBuildDir.dir(project.name)
    project.layout.buildDirectory.value(newSubprojectBuildDir)
}
subprojects {
    project.evaluationDependsOn(":app")
}

tasks.register<Delete>("clean") {
    delete(rootProject.layout.buildDirectory)
}

--------------------------------------------------
=== END OF FILE: android/build.gradle.kts ===


=== FILE: android/gradle.properties ===
--------------------------------------------------
org.gradle.jvmargs=-Xmx8G -XX:MaxMetaspaceSize=4G -XX:ReservedCodeCacheSize=512m -XX:+HeapDumpOnOutOfMemoryError
android.useAndroidX=true
android.enableJetifier=true

--------------------------------------------------
=== END OF FILE: android/gradle.properties ===


=== FILE: android/muscle_up_android.iml ===
--------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<module type="JAVA_MODULE" version="4">
  <component name="FacetManager">
    <facet type="android" name="Android">
      <configuration>
        <option name="ALLOW_USER_CONFIGURATION" value="false" />
        <option name="GEN_FOLDER_RELATIVE_PATH_APT" value="/gen" />
        <option name="GEN_FOLDER_RELATIVE_PATH_AIDL" value="/gen" />
        <option name="MANIFEST_FILE_RELATIVE_PATH" value="/app/src/main/AndroidManifest.xml" />
        <option name="RES_FOLDER_RELATIVE_PATH" value="/app/src/main/res" />
        <option name="ASSETS_FOLDER_RELATIVE_PATH" value="/app/src/main/assets" />
        <option name="LIBS_FOLDER_RELATIVE_PATH" value="/app/src/main/libs" />
        <option name="PROGUARD_LOGS_FOLDER_RELATIVE_PATH" value="/app/src/main/proguard_logs" />
      </configuration>
    </facet>
  </component>
  <component name="NewModuleRootManager" inherit-compiler-output="true">
    <exclude-output />
    <content url="file://$MODULE_DIR$">
      <sourceFolder url="file://$MODULE_DIR$/app/src/main/java" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/app/src/main/kotlin" isTestSource="false" />
      <sourceFolder url="file://$MODULE_DIR$/gen" isTestSource="false" generated="true" />
    </content>
    <orderEntry type="jdk" jdkName="Android API 29 Platform" jdkType="Android SDK" />
    <orderEntry type="sourceFolder" forTests="false" />
    <orderEntry type="library" name="Flutter for Android" level="project" />
    <orderEntry type="library" name="KotlinJavaRuntime" level="project" />
  </component>
</module>

--------------------------------------------------
=== END OF FILE: android/muscle_up_android.iml ===


=== FILE: android/settings.gradle.kts ===
--------------------------------------------------
pluginManagement {
    val flutterSdkPath = run {
        val properties = java.util.Properties()
        file("local.properties").inputStream().use { properties.load(it) }
        val flutterSdkPath = properties.getProperty("flutter.sdk")
        require(flutterSdkPath != null) { "flutter.sdk not set in local.properties" }
        flutterSdkPath
    }

    includeBuild("$flutterSdkPath/packages/flutter_tools/gradle")

    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}

plugins {
    id("dev.flutter.flutter-plugin-loader") version "1.0.0"
    id("com.android.application") version "8.7.3" apply false
    // START: FlutterFire Configuration
    id("com.google.gms.google-services") version("4.3.15") apply false
    // END: FlutterFire Configuration
    id("org.jetbrains.kotlin.android") version "2.1.0" apply false
}

include(":app")

--------------------------------------------------
=== END OF FILE: android/settings.gradle.kts ===


=== FILE: android/app/build.gradle.kts ===
--------------------------------------------------
plugins {
    id("com.android.application")
    // START: FlutterFire Configuration
    id("com.google.gms.google-services")
    // END: FlutterFire Configuration
    id("kotlin-android")
    // The Flutter Gradle Plugin must be applied after the Android and Kotlin Gradle plugins.
    id("dev.flutter.flutter-gradle-plugin")
}

android {
    namespace = "com.example.muscle_up"
    compileSdk = flutter.compileSdkVersion
    ndkVersion = flutter.ndkVersion

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_11
        targetCompatibility = JavaVersion.VERSION_11
    }

    kotlinOptions {
        jvmTarget = JavaVersion.VERSION_11.toString()
    }

    defaultConfig {
        // TODO: Specify your own unique Application ID (https://developer.android.com/studio/build/application-id.html).
        applicationId = "com.example.muscle_up"
        // You can update the following values to match your application needs.
        // For more information, see: https://flutter.dev/to/review-gradle-config.
        minSdk = flutter.minSdkVersion
        targetSdk = flutter.targetSdkVersion
        versionCode = flutter.versionCode
        versionName = flutter.versionName
    }

    buildTypes {
        release {
            // TODO: Add your own signing config for the release build.
            // Signing with the debug keys for now, so `flutter run --release` works.
            signingConfig = signingConfigs.getByName("debug")
        }
    }
}

flutter {
    source = "../.."
}

--------------------------------------------------
=== END OF FILE: android/app/build.gradle.kts ===


=== FILE: android/app/google-services.json ===
--------------------------------------------------
{
  "project_info": {
    "project_number": "1012783717502",
    "project_id": "muscle-up-8c275",
    "storage_bucket": "muscle-up-8c275.firebasestorage.app"
  },
  "client": [
    {
      "client_info": {
        "mobilesdk_app_id": "1:1012783717502:android:2f7ce9326b23c730938c2f",
        "android_client_info": {
          "package_name": "com.example.muscle_up"
        }
      },
      "oauth_client": [
        {
          "client_id": "1012783717502-sp0ocdvt826a594m08u2a67674t84pmd.apps.googleusercontent.com",
          "client_type": 1,
          "android_info": {
            "package_name": "com.example.muscle_up",
            "certificate_hash": "5f64da5e6979bd16c2ad006d7fc2c05c63be05fe"
          }
        },
        {
          "client_id": "1012783717502-kc8pdm9fisavd2bvmp86svfn2kob6hp5.apps.googleusercontent.com",
          "client_type": 3
        }
      ],
      "api_key": [
        {
          "current_key": "AIzaSyCnwYrzMP3nVK_bpX86pgItzDt-FK77NX8"
        }
      ],
      "services": {
        "appinvite_service": {
          "other_platform_oauth_client": [
            {
              "client_id": "1012783717502-kc8pdm9fisavd2bvmp86svfn2kob6hp5.apps.googleusercontent.com",
              "client_type": 3
            },
            {
              "client_id": "1012783717502-9ii5tn4ulcq8qv6rvh0ril514pdcm50l.apps.googleusercontent.com",
              "client_type": 2,
              "ios_info": {
                "bundle_id": "com.example.muscleUp"
              }
            }
          ]
        }
      }
    }
  ],
  "configuration_version": "1"
}
--------------------------------------------------
=== END OF FILE: android/app/google-services.json ===


=== FILE: android/app/src/debug/AndroidManifest.xml ===
--------------------------------------------------
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>

--------------------------------------------------
=== END OF FILE: android/app/src/debug/AndroidManifest.xml ===


=== FILE: android/app/src/main/AndroidManifest.xml ===
--------------------------------------------------
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <application
        android:label="muscle_up"
        android:name="${applicationName}"
        android:icon="@mipmap/ic_launcher">
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTop"
            android:taskAffinity=""
            android:theme="@style/LaunchTheme"
            android:configChanges="orientation|keyboardHidden|keyboard|screenSize|smallestScreenSize|locale|layoutDirection|fontScale|screenLayout|density|uiMode"
            android:hardwareAccelerated="true"
            android:windowSoftInputMode="adjustResize">
            <!-- Specifies an Android theme to apply to this Activity as soon as
                 the Android process has started. This theme is visible to the user
                 while the Flutter UI initializes. After that, this theme continues
                 to determine the Window background behind the Flutter UI. -->
            <meta-data
              android:name="io.flutter.embedding.android.NormalTheme"
              android:resource="@style/NormalTheme"
              />
            <intent-filter>
                <action android:name="android.intent.action.MAIN"/>
                <category android:name="android.intent.category.LAUNCHER"/>
            </intent-filter>
        </activity>
        <!-- Don't delete the meta-data below.
             This is used by the Flutter tool to generate GeneratedPluginRegistrant.java -->
        <meta-data
            android:name="flutterEmbedding"
            android:value="2" />
    </application>
    <!-- Required to query activities that can process text, see:
         https://developer.android.com/training/package-visibility and
         https://developer.android.com/reference/android/content/Intent#ACTION_PROCESS_TEXT.

         In particular, this is used by the Flutter engine in io.flutter.plugin.text.ProcessTextPlugin. -->
    <queries>
        <intent>
            <action android:name="android.intent.action.PROCESS_TEXT"/>
            <data android:mimeType="text/plain"/>
        </intent>
    </queries>
</manifest>

--------------------------------------------------
=== END OF FILE: android/app/src/main/AndroidManifest.xml ===


=== FILE: android/app/src/main/java/io/flutter/plugins/GeneratedPluginRegistrant.java ===
--------------------------------------------------
package io.flutter.plugins;

import androidx.annotation.Keep;
import androidx.annotation.NonNull;
import io.flutter.Log;

import io.flutter.embedding.engine.FlutterEngine;

/**
 * Generated file. Do not edit.
 * This file is generated by the Flutter tool based on the
 * plugins that support the Android platform.
 */
@Keep
public final class GeneratedPluginRegistrant {
  private static final String TAG = "GeneratedPluginRegistrant";
  public static void registerWith(@NonNull FlutterEngine flutterEngine) {
    try {
      flutterEngine.getPlugins().add(new io.flutter.plugins.firebase.firestore.FlutterFirebaseFirestorePlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin cloud_firestore, io.flutter.plugins.firebase.firestore.FlutterFirebaseFirestorePlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new io.flutter.plugins.firebase.auth.FlutterFirebaseAuthPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin firebase_auth, io.flutter.plugins.firebase.auth.FlutterFirebaseAuthPlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new io.flutter.plugins.firebase.core.FlutterFirebaseCorePlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin firebase_core, io.flutter.plugins.firebase.core.FlutterFirebaseCorePlugin", e);
    }
    try {
      flutterEngine.getPlugins().add(new io.flutter.plugins.googlesignin.GoogleSignInPlugin());
    } catch (Exception e) {
      Log.e(TAG, "Error registering plugin google_sign_in_android, io.flutter.plugins.googlesignin.GoogleSignInPlugin", e);
    }
  }
}

--------------------------------------------------
=== END OF FILE: android/app/src/main/java/io/flutter/plugins/GeneratedPluginRegistrant.java ===


=== FILE: android/app/src/main/kotlin/com/example/muscle_up/MainActivity.kt ===
--------------------------------------------------
package com.example.muscle_up

import io.flutter.embedding.android.FlutterActivity

class MainActivity : FlutterActivity()

--------------------------------------------------
=== END OF FILE: android/app/src/main/kotlin/com/example/muscle_up/MainActivity.kt ===


=== FILE: android/app/src/main/res/drawable/launch_background.xml ===
--------------------------------------------------
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="@android:color/white" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>

--------------------------------------------------
=== END OF FILE: android/app/src/main/res/drawable/launch_background.xml ===


=== FILE: android/app/src/main/res/drawable-v21/launch_background.xml ===
--------------------------------------------------
<?xml version="1.0" encoding="utf-8"?>
<!-- Modify this file to customize your launch splash screen -->
<layer-list xmlns:android="http://schemas.android.com/apk/res/android">
    <item android:drawable="?android:colorBackground" />

    <!-- You can insert your own image assets here -->
    <!-- <item>
        <bitmap
            android:gravity="center"
            android:src="@mipmap/launch_image" />
    </item> -->
</layer-list>

--------------------------------------------------
=== END OF FILE: android/app/src/main/res/drawable-v21/launch_background.xml ===


=== FILE: android/app/src/main/res/values/styles.xml ===
--------------------------------------------------
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is off -->
    <style name="LaunchTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Light.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>

--------------------------------------------------
=== END OF FILE: android/app/src/main/res/values/styles.xml ===


=== FILE: android/app/src/main/res/values-night/styles.xml ===
--------------------------------------------------
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Theme applied to the Android Window while the process is starting when the OS's Dark Mode setting is on -->
    <style name="LaunchTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <!-- Show a splash screen on the activity. Automatically removed when
             the Flutter engine draws its first frame -->
        <item name="android:windowBackground">@drawable/launch_background</item>
    </style>
    <!-- Theme applied to the Android Window as soon as the process has started.
         This theme determines the color of the Android Window while your
         Flutter UI initializes, as well as behind your Flutter UI while its
         running.

         This Theme is only used starting with V2 of Flutter's Android embedding. -->
    <style name="NormalTheme" parent="@android:style/Theme.Black.NoTitleBar">
        <item name="android:windowBackground">?android:colorBackground</item>
    </style>
</resources>

--------------------------------------------------
=== END OF FILE: android/app/src/main/res/values-night/styles.xml ===


=== FILE: android/app/src/profile/AndroidManifest.xml ===
--------------------------------------------------
<manifest xmlns:android="http://schemas.android.com/apk/res/android">
    <!-- The INTERNET permission is required for development. Specifically,
         the Flutter tool needs it to communicate with the running application
         to allow setting breakpoints, to provide hot reload, etc.
    -->
    <uses-permission android:name="android.permission.INTERNET"/>
</manifest>

--------------------------------------------------
=== END OF FILE: android/app/src/profile/AndroidManifest.xml ===


=== FILE: android/gradle/wrapper/gradle-wrapper.properties ===
--------------------------------------------------
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.12-all.zip

--------------------------------------------------
=== END OF FILE: android/gradle/wrapper/gradle-wrapper.properties ===


=== FILE: ios/.gitignore ===
--------------------------------------------------
**/dgph
*.mode1v3
*.mode2v3
*.moved-aside
*.pbxuser
*.perspectivev3
**/*sync/
.sconsign.dblite
.tags*
**/.vagrant/
**/DerivedData/
Icon?
**/Pods/
**/.symlinks/
profile
xcuserdata
**/.generated/
Flutter/App.framework
Flutter/Flutter.framework
Flutter/Flutter.podspec
Flutter/Generated.xcconfig
Flutter/ephemeral/
Flutter/app.flx
Flutter/app.zip
Flutter/flutter_assets/
Flutter/flutter_export_environment.sh
ServiceDefinitions.json
Runner/GeneratedPluginRegistrant.*

# Exceptions to above rules.
!default.mode1v3
!default.mode2v3
!default.pbxuser
!default.perspectivev3

--------------------------------------------------
=== END OF FILE: ios/.gitignore ===


=== FILE: ios/Flutter/AppFrameworkInfo.plist ===
--------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>CFBundleDevelopmentRegion</key>
  <string>en</string>
  <key>CFBundleExecutable</key>
  <string>App</string>
  <key>CFBundleIdentifier</key>
  <string>io.flutter.flutter.app</string>
  <key>CFBundleInfoDictionaryVersion</key>
  <string>6.0</string>
  <key>CFBundleName</key>
  <string>App</string>
  <key>CFBundlePackageType</key>
  <string>FMWK</string>
  <key>CFBundleShortVersionString</key>
  <string>1.0</string>
  <key>CFBundleSignature</key>
  <string>????</string>
  <key>CFBundleVersion</key>
  <string>1.0</string>
  <key>MinimumOSVersion</key>
  <string>12.0</string>
</dict>
</plist>

--------------------------------------------------
=== END OF FILE: ios/Flutter/AppFrameworkInfo.plist ===


=== FILE: ios/Flutter/Debug.xcconfig ===
--------------------------------------------------
#include "Generated.xcconfig"

--------------------------------------------------
=== END OF FILE: ios/Flutter/Debug.xcconfig ===


=== FILE: ios/Flutter/flutter_export_environment.sh ===
--------------------------------------------------
#!/bin/sh
# This is a generated file; do not edit or check into version control.
export "FLUTTER_ROOT=C:\Software\flutter\flutter"
export "FLUTTER_APPLICATION_PATH=C:\Users\levndays\Desktop\muscle_up"
export "COCOAPODS_PARALLEL_CODE_SIGN=true"
export "FLUTTER_TARGET=lib\main.dart"
export "FLUTTER_BUILD_DIR=build"
export "FLUTTER_BUILD_NAME=0.1.0"
export "FLUTTER_BUILD_NUMBER=0.1.0"
export "DART_OBFUSCATION=false"
export "TRACK_WIDGET_CREATION=true"
export "TREE_SHAKE_ICONS=false"
export "PACKAGE_CONFIG=.dart_tool/package_config.json"

--------------------------------------------------
=== END OF FILE: ios/Flutter/flutter_export_environment.sh ===


=== FILE: ios/Flutter/Generated.xcconfig ===
--------------------------------------------------
// This is a generated file; do not edit or check into version control.
FLUTTER_ROOT=C:\Software\flutter\flutter
FLUTTER_APPLICATION_PATH=C:\Users\levndays\Desktop\muscle_up
COCOAPODS_PARALLEL_CODE_SIGN=true
FLUTTER_TARGET=lib\main.dart
FLUTTER_BUILD_DIR=build
FLUTTER_BUILD_NAME=0.1.0
FLUTTER_BUILD_NUMBER=0.1.0
EXCLUDED_ARCHS[sdk=iphonesimulator*]=i386
EXCLUDED_ARCHS[sdk=iphoneos*]=armv7
DART_OBFUSCATION=false
TRACK_WIDGET_CREATION=true
TREE_SHAKE_ICONS=false
PACKAGE_CONFIG=.dart_tool/package_config.json

--------------------------------------------------
=== END OF FILE: ios/Flutter/Generated.xcconfig ===


=== FILE: ios/Flutter/Release.xcconfig ===
--------------------------------------------------
#include "Generated.xcconfig"

--------------------------------------------------
=== END OF FILE: ios/Flutter/Release.xcconfig ===


=== FILE: ios/Flutter/ephemeral/flutter_lldbinit ===
--------------------------------------------------
#
# Generated file, do not edit.
#

command script import --relative-to-command-file flutter_lldb_helper.py

--------------------------------------------------
=== END OF FILE: ios/Flutter/ephemeral/flutter_lldbinit ===


=== FILE: ios/Flutter/ephemeral/flutter_lldb_helper.py ===
--------------------------------------------------
#
# Generated file, do not edit.
#

import lldb

def handle_new_rx_page(frame: lldb.SBFrame, bp_loc, extra_args, intern_dict):
    """Intercept NOTIFY_DEBUGGER_ABOUT_RX_PAGES and touch the pages."""
    base = frame.register["x0"].GetValueAsAddress()
    page_len = frame.register["x1"].GetValueAsUnsigned()

    # Note: NOTIFY_DEBUGGER_ABOUT_RX_PAGES will check contents of the
    # first page to see if handled it correctly. This makes diagnosing
    # misconfiguration (e.g. missing breakpoint) easier.
    data = bytearray(page_len)
    data[0:8] = b'IHELPED!'

    error = lldb.SBError()
    frame.GetThread().GetProcess().WriteMemory(base, data, error)
    if not error.Success():
        print(f'Failed to write into {base}[+{page_len}]', error)
        return

def __lldb_init_module(debugger: lldb.SBDebugger, _):
    target = debugger.GetDummyTarget()
    # Caveat: must use BreakpointCreateByRegEx here and not
    # BreakpointCreateByName. For some reasons callback function does not
    # get carried over from dummy target for the later.
    bp = target.BreakpointCreateByRegex("^NOTIFY_DEBUGGER_ABOUT_RX_PAGES$")
    bp.SetScriptCallbackFunction('{}.handle_new_rx_page'.format(__name__))
    bp.SetAutoContinue(True)
    print("-- LLDB integration loaded --")

--------------------------------------------------
=== END OF FILE: ios/Flutter/ephemeral/flutter_lldb_helper.py ===


=== FILE: ios/Runner/AppDelegate.swift ===
--------------------------------------------------
import Flutter
import UIKit

@main
@objc class AppDelegate: FlutterAppDelegate {
  override func application(
    _ application: UIApplication,
    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?
  ) -> Bool {
    GeneratedPluginRegistrant.register(with: self)
    return super.application(application, didFinishLaunchingWithOptions: launchOptions)
  }
}

--------------------------------------------------
=== END OF FILE: ios/Runner/AppDelegate.swift ===


=== FILE: ios/Runner/GeneratedPluginRegistrant.h ===
--------------------------------------------------
//
//  Generated file. Do not edit.
//

// clang-format off

#ifndef GeneratedPluginRegistrant_h
#define GeneratedPluginRegistrant_h

#import <Flutter/Flutter.h>

NS_ASSUME_NONNULL_BEGIN

@interface GeneratedPluginRegistrant : NSObject
+ (void)registerWithRegistry:(NSObject<FlutterPluginRegistry>*)registry;
@end

NS_ASSUME_NONNULL_END
#endif /* GeneratedPluginRegistrant_h */

--------------------------------------------------
=== END OF FILE: ios/Runner/GeneratedPluginRegistrant.h ===


=== FILE: ios/Runner/GeneratedPluginRegistrant.m ===
--------------------------------------------------
//
//  Generated file. Do not edit.
//

// clang-format off

#import "GeneratedPluginRegistrant.h"

#if __has_include(<cloud_firestore/FLTFirebaseFirestorePlugin.h>)
#import <cloud_firestore/FLTFirebaseFirestorePlugin.h>
#else
@import cloud_firestore;
#endif

#if __has_include(<firebase_auth/FLTFirebaseAuthPlugin.h>)
#import <firebase_auth/FLTFirebaseAuthPlugin.h>
#else
@import firebase_auth;
#endif

#if __has_include(<firebase_core/FLTFirebaseCorePlugin.h>)
#import <firebase_core/FLTFirebaseCorePlugin.h>
#else
@import firebase_core;
#endif

#if __has_include(<google_sign_in_ios/FLTGoogleSignInPlugin.h>)
#import <google_sign_in_ios/FLTGoogleSignInPlugin.h>
#else
@import google_sign_in_ios;
#endif

@implementation GeneratedPluginRegistrant

+ (void)registerWithRegistry:(NSObject<FlutterPluginRegistry>*)registry {
  [FLTFirebaseFirestorePlugin registerWithRegistrar:[registry registrarForPlugin:@"FLTFirebaseFirestorePlugin"]];
  [FLTFirebaseAuthPlugin registerWithRegistrar:[registry registrarForPlugin:@"FLTFirebaseAuthPlugin"]];
  [FLTFirebaseCorePlugin registerWithRegistrar:[registry registrarForPlugin:@"FLTFirebaseCorePlugin"]];
  [FLTGoogleSignInPlugin registerWithRegistrar:[registry registrarForPlugin:@"FLTGoogleSignInPlugin"]];
}

@end

--------------------------------------------------
=== END OF FILE: ios/Runner/GeneratedPluginRegistrant.m ===


=== FILE: ios/Runner/Info.plist ===
--------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>$(DEVELOPMENT_LANGUAGE)</string>
	<key>CFBundleDisplayName</key>
	<string>Muscle Up</string>
	<key>CFBundleExecutable</key>
	<string>$(EXECUTABLE_NAME)</string>
	<key>CFBundleIdentifier</key>
	<string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>muscle_up</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>$(FLUTTER_BUILD_NAME)</string>
	<key>CFBundleSignature</key>
	<string>????</string>
	<key>CFBundleVersion</key>
	<string>$(FLUTTER_BUILD_NUMBER)</string>
	<key>LSRequiresIPhoneOS</key>
	<true/>
	<key>UILaunchStoryboardName</key>
	<string>LaunchScreen</string>
	<key>UIMainStoryboardFile</key>
	<string>Main</string>
	<key>UISupportedInterfaceOrientations</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
	<key>UISupportedInterfaceOrientations~ipad</key>
	<array>
		<string>UIInterfaceOrientationPortrait</string>
		<string>UIInterfaceOrientationPortraitUpsideDown</string>
		<string>UIInterfaceOrientationLandscapeLeft</string>
		<string>UIInterfaceOrientationLandscapeRight</string>
	</array>
	<key>CADisableMinimumFrameDurationOnPhone</key>
	<true/>
	<key>UIApplicationSupportsIndirectInputEvents</key>
	<true/>
</dict>
</plist>

--------------------------------------------------
=== END OF FILE: ios/Runner/Info.plist ===


=== FILE: ios/Runner/Runner-Bridging-Header.h ===
--------------------------------------------------
#import "GeneratedPluginRegistrant.h"

--------------------------------------------------
=== END OF FILE: ios/Runner/Runner-Bridging-Header.h ===


=== FILE: ios/Runner/Base.lproj/LaunchScreen.storyboard ===
--------------------------------------------------
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="12121" systemVersion="16G29" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" launchScreen="YES" colorMatched="YES" initialViewController="01J-lp-oVM">
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="12089"/>
    </dependencies>
    <scenes>
        <!--View Controller-->
        <scene sceneID="EHf-IW-A2E">
            <objects>
                <viewController id="01J-lp-oVM" sceneMemberID="viewController">
                    <layoutGuides>
                        <viewControllerLayoutGuide type="top" id="Ydg-fD-yQy"/>
                        <viewControllerLayoutGuide type="bottom" id="xbc-2k-c8Z"/>
                    </layoutGuides>
                    <view key="view" contentMode="scaleToFill" id="Ze5-6b-2t3">
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <subviews>
                            <imageView opaque="NO" clipsSubviews="YES" multipleTouchEnabled="YES" contentMode="center" image="LaunchImage" translatesAutoresizingMaskIntoConstraints="NO" id="YRO-k0-Ey4">
                            </imageView>
                        </subviews>
                        <color key="backgroundColor" red="1" green="1" blue="1" alpha="1" colorSpace="custom" customColorSpace="sRGB"/>
                        <constraints>
                            <constraint firstItem="YRO-k0-Ey4" firstAttribute="centerX" secondItem="Ze5-6b-2t3" secondAttribute="centerX" id="1a2-6s-vTC"/>
                            <constraint firstItem="YRO-k0-Ey4" firstAttribute="centerY" secondItem="Ze5-6b-2t3" secondAttribute="centerY" id="4X2-HB-R7a"/>
                        </constraints>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="iYj-Kq-Ea1" userLabel="First Responder" sceneMemberID="firstResponder"/>
            </objects>
            <point key="canvasLocation" x="53" y="375"/>
        </scene>
    </scenes>
    <resources>
        <image name="LaunchImage" width="168" height="185"/>
    </resources>
</document>

--------------------------------------------------
=== END OF FILE: ios/Runner/Base.lproj/LaunchScreen.storyboard ===


=== FILE: ios/Runner/Base.lproj/Main.storyboard ===
--------------------------------------------------
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<document type="com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB" version="3.0" toolsVersion="10117" systemVersion="15F34" targetRuntime="iOS.CocoaTouch" propertyAccessControl="none" useAutolayout="YES" useTraitCollections="YES" initialViewController="BYZ-38-t0r">
    <dependencies>
        <deployment identifier="iOS"/>
        <plugIn identifier="com.apple.InterfaceBuilder.IBCocoaTouchPlugin" version="10085"/>
    </dependencies>
    <scenes>
        <!--Flutter View Controller-->
        <scene sceneID="tne-QT-ifu">
            <objects>
                <viewController id="BYZ-38-t0r" customClass="FlutterViewController" sceneMemberID="viewController">
                    <layoutGuides>
                        <viewControllerLayoutGuide type="top" id="y3c-jy-aDJ"/>
                        <viewControllerLayoutGuide type="bottom" id="wfy-db-euE"/>
                    </layoutGuides>
                    <view key="view" contentMode="scaleToFill" id="8bC-Xf-vdC">
                        <rect key="frame" x="0.0" y="0.0" width="600" height="600"/>
                        <autoresizingMask key="autoresizingMask" widthSizable="YES" heightSizable="YES"/>
                        <color key="backgroundColor" white="1" alpha="1" colorSpace="custom" customColorSpace="calibratedWhite"/>
                    </view>
                </viewController>
                <placeholder placeholderIdentifier="IBFirstResponder" id="dkx-z0-nzr" sceneMemberID="firstResponder"/>
            </objects>
        </scene>
    </scenes>
</document>

--------------------------------------------------
=== END OF FILE: ios/Runner/Base.lproj/Main.storyboard ===


=== FILE: ios/Runner.xcodeproj/project.pbxproj ===
--------------------------------------------------
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 54;
	objects = {

/* Begin PBXBuildFile section */
		1498D2341E8E89220040F4C2 /* GeneratedPluginRegistrant.m in Sources */ = {isa = PBXBuildFile; fileRef = 1498D2331E8E89220040F4C2 /* GeneratedPluginRegistrant.m */; };
		331C808B294A63AB00263BE5 /* RunnerTests.swift in Sources */ = {isa = PBXBuildFile; fileRef = 331C807B294A618700263BE5 /* RunnerTests.swift */; };
		3B3967161E833CAA004F5970 /* AppFrameworkInfo.plist in Resources */ = {isa = PBXBuildFile; fileRef = 3B3967151E833CAA004F5970 /* AppFrameworkInfo.plist */; };
		74858FAF1ED2DC5600515810 /* AppDelegate.swift in Sources */ = {isa = PBXBuildFile; fileRef = 74858FAE1ED2DC5600515810 /* AppDelegate.swift */; };
		97C146FC1CF9000F007C117D /* Main.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = 97C146FA1CF9000F007C117D /* Main.storyboard */; };
		97C146FE1CF9000F007C117D /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 97C146FD1CF9000F007C117D /* Assets.xcassets */; };
		97C147011CF9000F007C117D /* LaunchScreen.storyboard in Resources */ = {isa = PBXBuildFile; fileRef = 97C146FF1CF9000F007C117D /* LaunchScreen.storyboard */; };
/* End PBXBuildFile section */

/* Begin PBXContainerItemProxy section */
		331C8085294A63A400263BE5 /* PBXContainerItemProxy */ = {
			isa = PBXContainerItemProxy;
			containerPortal = 97C146E61CF9000F007C117D /* Project object */;
			proxyType = 1;
			remoteGlobalIDString = 97C146ED1CF9000F007C117D;
			remoteInfo = Runner;
		};
/* End PBXContainerItemProxy section */

/* Begin PBXCopyFilesBuildPhase section */
		9705A1C41CF9048500538489 /* Embed Frameworks */ = {
			isa = PBXCopyFilesBuildPhase;
			buildActionMask = 2147483647;
			dstPath = "";
			dstSubfolderSpec = 10;
			files = (
			);
			name = "Embed Frameworks";
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXCopyFilesBuildPhase section */

/* Begin PBXFileReference section */
		1498D2321E8E86230040F4C2 /* GeneratedPluginRegistrant.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = GeneratedPluginRegistrant.h; sourceTree = "<group>"; };
		1498D2331E8E89220040F4C2 /* GeneratedPluginRegistrant.m */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.c.objc; path = GeneratedPluginRegistrant.m; sourceTree = "<group>"; };
		331C807B294A618700263BE5 /* RunnerTests.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RunnerTests.swift; sourceTree = "<group>"; };
		331C8081294A63A400263BE5 /* RunnerTests.xctest */ = {isa = PBXFileReference; explicitFileType = wrapper.cfbundle; includeInIndex = 0; path = RunnerTests.xctest; sourceTree = BUILT_PRODUCTS_DIR; };
		3B3967151E833CAA004F5970 /* AppFrameworkInfo.plist */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.plist.xml; name = AppFrameworkInfo.plist; path = Flutter/AppFrameworkInfo.plist; sourceTree = "<group>"; };
		74858FAD1ED2DC5600515810 /* Runner-Bridging-Header.h */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.c.h; path = "Runner-Bridging-Header.h"; sourceTree = "<group>"; };
		74858FAE1ED2DC5600515810 /* AppDelegate.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = AppDelegate.swift; sourceTree = "<group>"; };
		7AFA3C8E1D35360C0083082E /* Release.xcconfig */ = {isa = PBXFileReference; lastKnownFileType = text.xcconfig; name = Release.xcconfig; path = Flutter/Release.xcconfig; sourceTree = "<group>"; };
		9740EEB21CF90195004384FC /* Debug.xcconfig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xcconfig; name = Debug.xcconfig; path = Flutter/Debug.xcconfig; sourceTree = "<group>"; };
		9740EEB31CF90195004384FC /* Generated.xcconfig */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = text.xcconfig; name = Generated.xcconfig; path = Flutter/Generated.xcconfig; sourceTree = "<group>"; };
		97C146EE1CF9000F007C117D /* Runner.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = Runner.app; sourceTree = BUILT_PRODUCTS_DIR; };
		97C146FB1CF9000F007C117D /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.storyboard; name = Base; path = Base.lproj/Main.storyboard; sourceTree = "<group>"; };
		97C146FD1CF9000F007C117D /* Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; path = Assets.xcassets; sourceTree = "<group>"; };
		97C147001CF9000F007C117D /* Base */ = {isa = PBXFileReference; lastKnownFileType = file.storyboard; name = Base; path = Base.lproj/LaunchScreen.storyboard; sourceTree = "<group>"; };
		97C147021CF9000F007C117D /* Info.plist */ = {isa = PBXFileReference; lastKnownFileType = text.plist.xml; path = Info.plist; sourceTree = "<group>"; };
/* End PBXFileReference section */

/* Begin PBXFrameworksBuildPhase section */
		97C146EB1CF9000F007C117D /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		331C8082294A63A400263BE5 /* RunnerTests */ = {
			isa = PBXGroup;
			children = (
				331C807B294A618700263BE5 /* RunnerTests.swift */,
			);
			path = RunnerTests;
			sourceTree = "<group>";
		};
		9740EEB11CF90186004384FC /* Flutter */ = {
			isa = PBXGroup;
			children = (
				3B3967151E833CAA004F5970 /* AppFrameworkInfo.plist */,
				9740EEB21CF90195004384FC /* Debug.xcconfig */,
				7AFA3C8E1D35360C0083082E /* Release.xcconfig */,
				9740EEB31CF90195004384FC /* Generated.xcconfig */,
			);
			name = Flutter;
			sourceTree = "<group>";
		};
		97C146E51CF9000F007C117D = {
			isa = PBXGroup;
			children = (
				9740EEB11CF90186004384FC /* Flutter */,
				97C146F01CF9000F007C117D /* Runner */,
				97C146EF1CF9000F007C117D /* Products */,
				331C8082294A63A400263BE5 /* RunnerTests */,
			);
			sourceTree = "<group>";
		};
		97C146EF1CF9000F007C117D /* Products */ = {
			isa = PBXGroup;
			children = (
				97C146EE1CF9000F007C117D /* Runner.app */,
				331C8081294A63A400263BE5 /* RunnerTests.xctest */,
			);
			name = Products;
			sourceTree = "<group>";
		};
		97C146F01CF9000F007C117D /* Runner */ = {
			isa = PBXGroup;
			children = (
				97C146FA1CF9000F007C117D /* Main.storyboard */,
				97C146FD1CF9000F007C117D /* Assets.xcassets */,
				97C146FF1CF9000F007C117D /* LaunchScreen.storyboard */,
				97C147021CF9000F007C117D /* Info.plist */,
				1498D2321E8E86230040F4C2 /* GeneratedPluginRegistrant.h */,
				1498D2331E8E89220040F4C2 /* GeneratedPluginRegistrant.m */,
				74858FAE1ED2DC5600515810 /* AppDelegate.swift */,
				74858FAD1ED2DC5600515810 /* Runner-Bridging-Header.h */,
			);
			path = Runner;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		331C8080294A63A400263BE5 /* RunnerTests */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 331C8087294A63A400263BE5 /* Build configuration list for PBXNativeTarget "RunnerTests" */;
			buildPhases = (
				331C807D294A63A400263BE5 /* Sources */,
				331C807F294A63A400263BE5 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
				331C8086294A63A400263BE5 /* PBXTargetDependency */,
			);
			name = RunnerTests;
			productName = RunnerTests;
			productReference = 331C8081294A63A400263BE5 /* RunnerTests.xctest */;
			productType = "com.apple.product-type.bundle.unit-test";
		};
		97C146ED1CF9000F007C117D /* Runner */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 97C147051CF9000F007C117D /* Build configuration list for PBXNativeTarget "Runner" */;
			buildPhases = (
				9740EEB61CF901F6004384FC /* Run Script */,
				97C146EA1CF9000F007C117D /* Sources */,
				97C146EB1CF9000F007C117D /* Frameworks */,
				97C146EC1CF9000F007C117D /* Resources */,
				9705A1C41CF9048500538489 /* Embed Frameworks */,
				3B06AD1E1E4923F5004D2608 /* Thin Binary */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = Runner;
			productName = Runner;
			productReference = 97C146EE1CF9000F007C117D /* Runner.app */;
			productType = "com.apple.product-type.application";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		97C146E61CF9000F007C117D /* Project object */ = {
			isa = PBXProject;
			attributes = {
				BuildIndependentTargetsInParallel = YES;
				LastUpgradeCheck = 1510;
				ORGANIZATIONNAME = "";
				TargetAttributes = {
					331C8080294A63A400263BE5 = {
						CreatedOnToolsVersion = 14.0;
						TestTargetID = 97C146ED1CF9000F007C117D;
					};
					97C146ED1CF9000F007C117D = {
						CreatedOnToolsVersion = 7.3.1;
						LastSwiftMigration = 1100;
					};
				};
			};
			buildConfigurationList = 97C146E91CF9000F007C117D /* Build configuration list for PBXProject "Runner" */;
			compatibilityVersion = "Xcode 9.3";
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
				Base,
			);
			mainGroup = 97C146E51CF9000F007C117D;
			productRefGroup = 97C146EF1CF9000F007C117D /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				97C146ED1CF9000F007C117D /* Runner */,
				331C8080294A63A400263BE5 /* RunnerTests */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		331C807F294A63A400263BE5 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		97C146EC1CF9000F007C117D /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				97C147011CF9000F007C117D /* LaunchScreen.storyboard in Resources */,
				3B3967161E833CAA004F5970 /* AppFrameworkInfo.plist in Resources */,
				97C146FE1CF9000F007C117D /* Assets.xcassets in Resources */,
				97C146FC1CF9000F007C117D /* Main.storyboard in Resources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXShellScriptBuildPhase section */
		3B06AD1E1E4923F5004D2608 /* Thin Binary */ = {
			isa = PBXShellScriptBuildPhase;
			alwaysOutOfDate = 1;
			buildActionMask = 2147483647;
			files = (
			);
			inputPaths = (
				"${TARGET_BUILD_DIR}/${INFOPLIST_PATH}",
			);
			name = "Thin Binary";
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "/bin/sh \"$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh\" embed_and_thin";
		};
		9740EEB61CF901F6004384FC /* Run Script */ = {
			isa = PBXShellScriptBuildPhase;
			alwaysOutOfDate = 1;
			buildActionMask = 2147483647;
			files = (
			);
			inputPaths = (
			);
			name = "Run Script";
			outputPaths = (
			);
			runOnlyForDeploymentPostprocessing = 0;
			shellPath = /bin/sh;
			shellScript = "/bin/sh \"$FLUTTER_ROOT/packages/flutter_tools/bin/xcode_backend.sh\" build";
		};
/* End PBXShellScriptBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		331C807D294A63A400263BE5 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				331C808B294A63AB00263BE5 /* RunnerTests.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
		97C146EA1CF9000F007C117D /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				74858FAF1ED2DC5600515810 /* AppDelegate.swift in Sources */,
				1498D2341E8E89220040F4C2 /* GeneratedPluginRegistrant.m in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin PBXTargetDependency section */
		331C8086294A63A400263BE5 /* PBXTargetDependency */ = {
			isa = PBXTargetDependency;
			target = 97C146ED1CF9000F007C117D /* Runner */;
			targetProxy = 331C8085294A63A400263BE5 /* PBXContainerItemProxy */;
		};
/* End PBXTargetDependency section */

/* Begin PBXVariantGroup section */
		97C146FA1CF9000F007C117D /* Main.storyboard */ = {
			isa = PBXVariantGroup;
			children = (
				97C146FB1CF9000F007C117D /* Base */,
			);
			name = Main.storyboard;
			sourceTree = "<group>";
		};
		97C146FF1CF9000F007C117D /* LaunchScreen.storyboard */ = {
			isa = PBXVariantGroup;
			children = (
				97C147001CF9000F007C117D /* Base */,
			);
			name = LaunchScreen.storyboard;
			sourceTree = "<group>";
		};
/* End PBXVariantGroup section */

/* Begin XCBuildConfiguration section */
		249021D3217E4FDB00AE95B9 /* Profile */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 12.0;
				MTL_ENABLE_DEBUG_INFO = NO;
				SDKROOT = iphoneos;
				SUPPORTED_PLATFORMS = iphoneos;
				TARGETED_DEVICE_FAMILY = "1,2";
				VALIDATE_PRODUCT = YES;
			};
			name = Profile;
		};
		249021D4217E4FDB00AE95B9 /* Profile */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 7AFA3C8E1D35360C0083082E /* Release.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CURRENT_PROJECT_VERSION = "$(FLUTTER_BUILD_NUMBER)";
				ENABLE_BITCODE = NO;
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.example.muscleUp;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_OBJC_BRIDGING_HEADER = "Runner/Runner-Bridging-Header.h";
				SWIFT_VERSION = 5.0;
				VERSIONING_SYSTEM = "apple-generic";
			};
			name = Profile;
		};
		331C8088294A63A400263BE5 /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.example.muscleUp.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = DEBUG;
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Runner.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Runner";
			};
			name = Debug;
		};
		331C8089294A63A400263BE5 /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.example.muscleUp.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Runner.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Runner";
			};
			name = Release;
		};
		331C808A294A63A400263BE5 /* Profile */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				BUNDLE_LOADER = "$(TEST_HOST)";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				GENERATE_INFOPLIST_FILE = YES;
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = com.example.muscleUp.RunnerTests;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_VERSION = 5.0;
				TEST_HOST = "$(BUILT_PRODUCTS_DIR)/Runner.app/$(BUNDLE_EXECUTABLE_FOLDER_PATH)/Runner";
			};
			name = Profile;
		};
		97C147031CF9000F007C117D /* Debug */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = dwarf;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 12.0;
				MTL_ENABLE_DEBUG_INFO = YES;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = iphoneos;
				TARGETED_DEVICE_FAMILY = "1,2";
			};
			name = Debug;
		};
		97C147041CF9000F007C117D /* Release */ = {
			isa = XCBuildConfiguration;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++0x";
				CLANG_CXX_LIBRARY = "libc++";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				"CODE_SIGN_IDENTITY[sdk=iphoneos*]" = "iPhone Developer";
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_C_LANGUAGE_STANDARD = gnu99;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				IPHONEOS_DEPLOYMENT_TARGET = 12.0;
				MTL_ENABLE_DEBUG_INFO = NO;
				SDKROOT = iphoneos;
				SUPPORTED_PLATFORMS = iphoneos;
				SWIFT_COMPILATION_MODE = wholemodule;
				SWIFT_OPTIMIZATION_LEVEL = "-O";
				TARGETED_DEVICE_FAMILY = "1,2";
				VALIDATE_PRODUCT = YES;
			};
			name = Release;
		};
		97C147061CF9000F007C117D /* Debug */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 9740EEB21CF90195004384FC /* Debug.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CURRENT_PROJECT_VERSION = "$(FLUTTER_BUILD_NUMBER)";
				ENABLE_BITCODE = NO;
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.example.muscleUp;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_OBJC_BRIDGING_HEADER = "Runner/Runner-Bridging-Header.h";
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				SWIFT_VERSION = 5.0;
				VERSIONING_SYSTEM = "apple-generic";
			};
			name = Debug;
		};
		97C147071CF9000F007C117D /* Release */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 7AFA3C8E1D35360C0083082E /* Release.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				CLANG_ENABLE_MODULES = YES;
				CURRENT_PROJECT_VERSION = "$(FLUTTER_BUILD_NUMBER)";
				ENABLE_BITCODE = NO;
				INFOPLIST_FILE = Runner/Info.plist;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				PRODUCT_BUNDLE_IDENTIFIER = com.example.muscleUp;
				PRODUCT_NAME = "$(TARGET_NAME)";
				SWIFT_OBJC_BRIDGING_HEADER = "Runner/Runner-Bridging-Header.h";
				SWIFT_VERSION = 5.0;
				VERSIONING_SYSTEM = "apple-generic";
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		331C8087294A63A400263BE5 /* Build configuration list for PBXNativeTarget "RunnerTests" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				331C8088294A63A400263BE5 /* Debug */,
				331C8089294A63A400263BE5 /* Release */,
				331C808A294A63A400263BE5 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		97C146E91CF9000F007C117D /* Build configuration list for PBXProject "Runner" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				97C147031CF9000F007C117D /* Debug */,
				97C147041CF9000F007C117D /* Release */,
				249021D3217E4FDB00AE95B9 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		97C147051CF9000F007C117D /* Build configuration list for PBXNativeTarget "Runner" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				97C147061CF9000F007C117D /* Debug */,
				97C147071CF9000F007C117D /* Release */,
				249021D4217E4FDB00AE95B9 /* Profile */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */
	};
	rootObject = 97C146E61CF9000F007C117D /* Project object */;
}

--------------------------------------------------
=== END OF FILE: ios/Runner.xcodeproj/project.pbxproj ===


=== FILE: ios/Runner.xcodeproj/project.xcworkspace/contents.xcworkspacedata ===
--------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "self:">
   </FileRef>
</Workspace>

--------------------------------------------------
=== END OF FILE: ios/Runner.xcodeproj/project.xcworkspace/contents.xcworkspacedata ===


=== FILE: ios/Runner.xcodeproj/project.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist ===
--------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>IDEDidComputeMac32BitWarning</key>
	<true/>
</dict>
</plist>

--------------------------------------------------
=== END OF FILE: ios/Runner.xcodeproj/project.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist ===


=== FILE: ios/Runner.xcodeproj/project.xcworkspace/xcshareddata/WorkspaceSettings.xcsettings ===
--------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>PreviewsEnabled</key>
	<false/>
</dict>
</plist>

--------------------------------------------------
=== END OF FILE: ios/Runner.xcodeproj/project.xcworkspace/xcshareddata/WorkspaceSettings.xcsettings ===


=== FILE: ios/Runner.xcodeproj/xcshareddata/xcschemes/Runner.xcscheme ===
--------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "1510"
   version = "1.3">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "97C146ED1CF9000F007C117D"
               BuildableName = "Runner.app"
               BlueprintName = "Runner"
               ReferencedContainer = "container:Runner.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      customLLDBInitFile = "$(SRCROOT)/Flutter/ephemeral/flutter_lldbinit"
      shouldUseLaunchSchemeArgsEnv = "YES">
      <MacroExpansion>
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "97C146ED1CF9000F007C117D"
            BuildableName = "Runner.app"
            BlueprintName = "Runner"
            ReferencedContainer = "container:Runner.xcodeproj">
         </BuildableReference>
      </MacroExpansion>
      <Testables>
         <TestableReference
            skipped = "NO"
            parallelizable = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "331C8080294A63A400263BE5"
               BuildableName = "RunnerTests.xctest"
               BlueprintName = "RunnerTests"
               ReferencedContainer = "container:Runner.xcodeproj">
            </BuildableReference>
         </TestableReference>
      </Testables>
   </TestAction>
   <LaunchAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      customLLDBInitFile = "$(SRCROOT)/Flutter/ephemeral/flutter_lldbinit"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      enableGPUValidationMode = "1"
      allowLocationSimulation = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "97C146ED1CF9000F007C117D"
            BuildableName = "Runner.app"
            BlueprintName = "Runner"
            ReferencedContainer = "container:Runner.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Profile"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "97C146ED1CF9000F007C117D"
            BuildableName = "Runner.app"
            BlueprintName = "Runner"
            ReferencedContainer = "container:Runner.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>

--------------------------------------------------
=== END OF FILE: ios/Runner.xcodeproj/xcshareddata/xcschemes/Runner.xcscheme ===


=== FILE: ios/Runner.xcworkspace/contents.xcworkspacedata ===
--------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<Workspace
   version = "1.0">
   <FileRef
      location = "group:Runner.xcodeproj">
   </FileRef>
</Workspace>

--------------------------------------------------
=== END OF FILE: ios/Runner.xcworkspace/contents.xcworkspacedata ===


=== FILE: ios/Runner.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist ===
--------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>IDEDidComputeMac32BitWarning</key>
	<true/>
</dict>
</plist>

--------------------------------------------------
=== END OF FILE: ios/Runner.xcworkspace/xcshareddata/IDEWorkspaceChecks.plist ===


=== FILE: ios/Runner.xcworkspace/xcshareddata/WorkspaceSettings.xcsettings ===
--------------------------------------------------
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>PreviewsEnabled</key>
	<false/>
</dict>
</plist>

--------------------------------------------------
=== END OF FILE: ios/Runner.xcworkspace/xcshareddata/WorkspaceSettings.xcsettings ===


=== FILE: ios/RunnerTests/RunnerTests.swift ===
--------------------------------------------------
import Flutter
import UIKit
import XCTest

class RunnerTests: XCTestCase {

  func testExample() {
    // If you add code to the Runner application, consider adding tests here.
    // See https://developer.apple.com/documentation/xctest for more information about using XCTest.
  }

}

--------------------------------------------------
=== END OF FILE: ios/RunnerTests/RunnerTests.swift ===


=== FILE: lib/auth_gate.dart ===
--------------------------------------------------
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';
import 'home_page.dart'; // Переконайся, що цей файл існує
import 'login_page.dart'; // Переконайся, що цей файл існує

class AuthGate extends StatelessWidget {
  const AuthGate({super.key}); // const конструктор

  @override
  Widget build(BuildContext context) {
    return StreamBuilder<User?>(
      stream: FirebaseAuth.instance.authStateChanges(),
      builder: (context, snapshot) {
        // Йде перевірка з'єднання
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Scaffold(
            body: Center(
              child: CircularProgressIndicator(),
            ),
          );
        }

        // Користувач увійшов
        if (snapshot.hasData) {
          return const HomePage(); // Використовуємо const, якщо HomePage має const конструктор
        }

        // Користувач не увійшов або сталася помилка (snapshot.hasError)
        // У простому випадку, якщо немає даних, показуємо логін
        return const LoginPage(); // Використовуємо const, якщо LoginPage має const конструктор
      },
    );
  }
}
--------------------------------------------------
=== END OF FILE: lib/auth_gate.dart ===


=== FILE: lib/firebase_options.dart ===
--------------------------------------------------
// File generated by FlutterFire CLI.
// ignore_for_file: type=lint
import 'package:firebase_core/firebase_core.dart' show FirebaseOptions;
import 'package:flutter/foundation.dart'
    show defaultTargetPlatform, kIsWeb, TargetPlatform;

/// Default [FirebaseOptions] for use with your Firebase apps.
///
/// Example:
/// ```dart
/// import 'firebase_options.dart';
/// // ...
/// await Firebase.initializeApp(
///   options: DefaultFirebaseOptions.currentPlatform,
/// );
/// ```
class DefaultFirebaseOptions {
  static FirebaseOptions get currentPlatform {
    if (kIsWeb) {
      return web;
    }
    switch (defaultTargetPlatform) {
      case TargetPlatform.android:
        return android;
      case TargetPlatform.iOS:
        return ios;
      case TargetPlatform.macOS:
        return macos;
      case TargetPlatform.windows:
        return windows;
      case TargetPlatform.linux:
        throw UnsupportedError(
          'DefaultFirebaseOptions have not been configured for linux - '
          'you can reconfigure this by running the FlutterFire CLI again.',
        );
      default:
        throw UnsupportedError(
          'DefaultFirebaseOptions are not supported for this platform.',
        );
    }
  }

  static const FirebaseOptions web = FirebaseOptions(
    apiKey: 'AIzaSyDXdgCNhubTMaavu2na3KA3CAvPlriiPOI',
    appId: '1:1012783717502:web:89f5605ac9ecd155938c2f',
    messagingSenderId: '1012783717502',
    projectId: 'muscle-up-8c275',
    authDomain: 'muscle-up-8c275.firebaseapp.com',
    storageBucket: 'muscle-up-8c275.firebasestorage.app',
    measurementId: 'G-GV825LKZPE',
  );

  static const FirebaseOptions android = FirebaseOptions(
    apiKey: 'AIzaSyCnwYrzMP3nVK_bpX86pgItzDt-FK77NX8',
    appId: '1:1012783717502:android:2f7ce9326b23c730938c2f',
    messagingSenderId: '1012783717502',
    projectId: 'muscle-up-8c275',
    storageBucket: 'muscle-up-8c275.firebasestorage.app',
  );

  static const FirebaseOptions ios = FirebaseOptions(
    apiKey: 'AIzaSyCH_-IcY1EU-mHG5E8-Gj9W2iCjcmisBfk',
    appId: '1:1012783717502:ios:debb2939085adc3f938c2f',
    messagingSenderId: '1012783717502',
    projectId: 'muscle-up-8c275',
    storageBucket: 'muscle-up-8c275.firebasestorage.app',
    iosBundleId: 'com.example.muscleUp',
  );

  static const FirebaseOptions macos = FirebaseOptions(
    apiKey: 'AIzaSyCH_-IcY1EU-mHG5E8-Gj9W2iCjcmisBfk',
    appId: '1:1012783717502:ios:debb2939085adc3f938c2f',
    messagingSenderId: '1012783717502',
    projectId: 'muscle-up-8c275',
    storageBucket: 'muscle-up-8c275.firebasestorage.app',
    iosBundleId: 'com.example.muscleUp',
  );

  static const FirebaseOptions windows = FirebaseOptions(
    apiKey: 'AIzaSyDXdgCNhubTMaavu2na3KA3CAvPlriiPOI',
    appId: '1:1012783717502:web:a6ef83f4982ba06e938c2f',
    messagingSenderId: '1012783717502',
    projectId: 'muscle-up-8c275',
    authDomain: 'muscle-up-8c275.firebaseapp.com',
    storageBucket: 'muscle-up-8c275.firebasestorage.app',
    measurementId: 'G-8LRCSHJ4VK',
  );
}

--------------------------------------------------
=== END OF FILE: lib/firebase_options.dart ===


=== FILE: lib/home_page.dart ===
--------------------------------------------------
import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter/material.dart';

class HomePage extends StatelessWidget {
  const HomePage({super.key}); // const конструктор

  @override
  Widget build(BuildContext context) {
    final User? user = FirebaseAuth.instance.currentUser;

    return Scaffold(
      appBar: AppBar(
        title: const Text('Головна сторінка'),
        centerTitle: true,
        actions: [
          IconButton(
            icon: const Icon(Icons.logout),
            tooltip: 'Вийти',
            onPressed: () async {
              try {
                await FirebaseAuth.instance.signOut();
                // AuthGate автоматично обробить перенаправлення на LoginPage
              } catch (e) {
                 ScaffoldMessenger.of(context).showSnackBar(
                   SnackBar(content: Text('Помилка виходу: ${e.toString()}')),
                 );
              }
            },
          ),
        ],
      ),
      body: Center(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: <Widget>[
              Text(
                'Вітаємо!',
                style: Theme.of(context).textTheme.headlineMedium,
              ),
              const SizedBox(height: 10),
              if (user != null) ...[
                if (user.displayName != null && user.displayName!.isNotEmpty)
                  Text('Ім\'я: ${user.displayName}', style: const TextStyle(fontSize: 18)),
                Text('Email: ${user.email}',  style: const TextStyle(fontSize: 18)),
                const SizedBox(height: 20),
                Text('User ID: ${user.uid}', style: const TextStyle(fontSize: 14, color: Colors.grey)),
              ] else
                const Text('Інформація про користувача недоступна.'),
            ],
          ),
        ),
      ),
    );
  }
}
--------------------------------------------------
=== END OF FILE: lib/home_page.dart ===


=== FILE: lib/login_page.dart ===
--------------------------------------------------
import 'package:flutter/material.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:google_sign_in/google_sign_in.dart';
import 'package:cloud_firestore/cloud_firestore.dart'; // Додано для FieldValue та FirebaseFirestore

class LoginPage extends StatefulWidget {
  const LoginPage({super.key});

  @override
  State<LoginPage> createState() => _LoginPageState();
}

class _LoginPageState extends State<LoginPage> with TickerProviderStateMixin { // TickerProviderStateMixin для кількох контролерів
  final _formKey = GlobalKey<FormState>();
  final TextEditingController _emailController = TextEditingController();
  final TextEditingController _passwordController = TextEditingController();

  bool _isLoading = false;
  bool _isLogin = true;
  String? _errorMessage;

  // Кольори
  static const Color primaryOrange = Color(0xFFED5D1A);
  static const Color textBlack = Colors.black87;
  static const Color textGrey = Color(0xFF757575);
  static const Color subtleOrangeBase = Color(0xFFFFF0E5); // Базовий світло-оранжевий
  static const Color whiteWithOpacity = Colors.white70; // Білий з прозорістю

  // Для анімації градієнта
  late AnimationController _gradientController1;
  late AnimationController _gradientController2;
  late Animation<Alignment> _alignmentAnimation1;
  late Animation<Alignment> _alignmentAnimation2;

  // Кольори для шарів градієнта
  final List<Color> _gradientColors1 = [
    primaryOrange.withOpacity(0.25), // Зменшена насиченість
    subtleOrangeBase.withOpacity(0.4),
    whiteWithOpacity.withOpacity(0.3),
  ];
  final List<Color> _gradientColors2 = [
    subtleOrangeBase.withOpacity(0.5),
    primaryOrange.withOpacity(0.15), // Ще менша насиченість
    Colors.white.withOpacity(0.35),
  ];


  @override
  void initState() {
    super.initState();
    _gradientController1 = AnimationController(
      vsync: this,
      duration: const Duration(seconds: 10), // Різні тривалості
    )..repeat(reverse: true);

    _gradientController2 = AnimationController(
      vsync: this,
      duration: const Duration(seconds: 13), // Різні тривалості
    )..repeat(reverse: true);

    _alignmentAnimation1 = TweenSequence<Alignment>([
      TweenSequenceItem(tween: AlignmentTween(begin: Alignment.topLeft, end: Alignment.bottomRight), weight: 1),
      TweenSequenceItem(tween: AlignmentTween(begin: Alignment.bottomRight, end: Alignment.centerLeft), weight: 1),
      TweenSequenceItem(tween: AlignmentTween(begin: Alignment.centerLeft, end: Alignment.topRight), weight: 1),
      TweenSequenceItem(tween: AlignmentTween(begin: Alignment.topRight, end: Alignment.topLeft), weight: 1),
    ]).animate(CurvedAnimation(parent: _gradientController1, curve: Curves.easeInOut));

    _alignmentAnimation2 = TweenSequence<Alignment>([
      TweenSequenceItem(tween: AlignmentTween(begin: Alignment.bottomLeft, end: Alignment.topRight), weight: 1),
      TweenSequenceItem(tween: AlignmentTween(begin: Alignment.topRight, end: Alignment.centerRight), weight: 1),
      TweenSequenceItem(tween: AlignmentTween(begin: Alignment.centerRight, end: Alignment.bottomLeft), weight: 1),
    ]).animate(CurvedAnimation(parent: _gradientController2, curve: Curves.easeInOut));
  }

  Future<void> _createInitialUserProfile(User user) async {
    final firestore = FirebaseFirestore.instance;
    final userDocRef = firestore.collection('users').doc(user.uid);

    final docSnapshot = await userDocRef.get();
    if (docSnapshot.exists) {
      print("User profile already exists for ${user.uid}");
      return;
    }
    try {
      await userDocRef.set({
        'uid': user.uid,
        'email': user.email?.toLowerCase(),
        'displayName': user.displayName,
        'profilePictureUrl': user.photoURL,
        'username': null,
        'xp': 0,
        'level': 1,
        'currentStreak': 0,
        'longestStreak': 0,
        'lastWorkoutTimestamp': null,
        'scheduledWorkoutDays': [],
        'preferredUnits': 'kg',
        'currentLeagueId': null,
        'city': null,
        'country': null,
        'isProfilePublic': true,
        'fcmTokens': [],
        'appSettings': {},
        'initialFitnessLevel': null,
        'profileSetupComplete': false, // Важливо для перенаправлення на ProfileSetupPage
        'createdAt': FieldValue.serverTimestamp(),
        'updatedAt': FieldValue.serverTimestamp(),
      });
      print("Initial user profile created for ${user.uid}");
    } catch (e) {
      print("Error creating initial user profile: $e");
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('Помилка створення профілю: ${e.toString()}')),
        );
      }
    }
  }

  Future<void> _submitForm() async {
    if (!_formKey.currentState!.validate()) return;
    setState(() { _isLoading = true; _errorMessage = null; });

    try {
      UserCredential userCredential;
      if (_isLogin) {
        userCredential = await FirebaseAuth.instance.signInWithEmailAndPassword(
          email: _emailController.text.trim(),
          password: _passwordController.text.trim(),
        );
      } else {
        userCredential = await FirebaseAuth.instance.createUserWithEmailAndPassword(
          email: _emailController.text.trim(),
          password: _passwordController.text.trim(),
        );
        if (userCredential.user != null) {
          await _createInitialUserProfile(userCredential.user!);
        }
      }
    } on FirebaseAuthException catch (e) {
      setState(() => _errorMessage = e.message ?? 'Сталася помилка.');
    } catch (e) {
      setState(() => _errorMessage = 'Сталася невідома помилка.');
    } finally {
      if (mounted) setState(() => _isLoading = false);
    }
  }

  Future<void> _signInWithGoogle() async {
    setState(() { _isLoading = true; _errorMessage = null; });
    try {
      final GoogleSignInAccount? googleUser = await GoogleSignIn().signIn();
      if (googleUser == null) {
        setState(() => _isLoading = false);
        return;
      }
      final GoogleSignInAuthentication googleAuth = await googleUser.authentication;
      final AuthCredential credential = GoogleAuthProvider.credential(
        accessToken: googleAuth.accessToken, idToken: googleAuth.idToken,
      );
      UserCredential userCredential = await FirebaseAuth.instance.signInWithCredential(credential);
      
      if ((userCredential.additionalUserInfo?.isNewUser ?? false) && userCredential.user != null) {
        await _createInitialUserProfile(userCredential.user!);
      }
    } on FirebaseAuthException catch (e) {
      setState(() => _errorMessage = e.message ?? 'Помилка входу через Google.');
    } catch (e) {
      setState(() => _errorMessage = 'Невідома помилка: ${e.toString()}');
    } finally {
      if (mounted) setState(() => _isLoading = false);
    }
  }

  @override
  void dispose() {
    _emailController.dispose();
    _passwordController.dispose();
    _gradientController1.dispose();
    _gradientController2.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Stack( // Використовуємо Stack для накладання градієнтів та контенту
        children: [
          // Шар градієнта 1
          AnimatedBuilder(
            animation: _gradientController1,
            builder: (context, child) {
              return Container(
                decoration: BoxDecoration(
                  gradient: LinearGradient(
                    colors: _gradientColors1,
                    begin: _alignmentAnimation1.value,
                    end: -_alignmentAnimation1.value, // Рух в протилежному напрямку
                    stops: const [0.0, 0.5, 1.0],
                  ),
                ),
              );
            },
          ),
          // Шар градієнта 2
          AnimatedBuilder(
            animation: _gradientController2,
            builder: (context, child) {
              return Container(
                decoration: BoxDecoration(
                  gradient: LinearGradient(
                    colors: _gradientColors2,
                    begin: _alignmentAnimation2.value,
                    end: -_alignmentAnimation2.value, // Рух в протилежному напрямку
                    stops: const [0.0, 0.4, 1.0], // Трохи інші stops
                  ),
                ),
              );
            },
          ),
          // Основний контент сторінки
          SafeArea(
            child: Center(
              child: SingleChildScrollView(
                padding: const EdgeInsets.symmetric(horizontal: 24.0, vertical: 15.0), // Зменшено вертикальний відступ
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.start, // Щоб заголовок був вгорі
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: <Widget>[
                    // MuscleUP Title - Зменшено та переміщено вгору
                    Padding(
                      padding: const EdgeInsets.only(top: 15.0, bottom: 40.0), // Відступи
                      child: RichText(
                        textAlign: TextAlign.center,
                        text: TextSpan( // Важливо встановити стиль за замовчуванням тут
                          style: DefaultTextStyle.of(context).style.copyWith(fontFamily: 'Inter'), // Для успадкування шрифта
                          children: <TextSpan>[
                            TextSpan(
                                text: 'Muscle',
                                style: TextStyle(
                                  fontSize: 30, // Зменшений розмір
                                  fontWeight: FontWeight.bold,
                                  color: primaryOrange,
                                )),
                            TextSpan(
                                text: 'UP',
                                style: TextStyle(
                                  fontSize: 30, // Зменшений розмір
                                  fontWeight: FontWeight.bold,
                                  color: textBlack,
                                )),
                          ],
                        ),
                      ),
                    ),

                    // Sign In Title
                    Text(
                      _isLogin ? 'Sign In' : 'Sign Up',
                      textAlign: TextAlign.center,
                      style: const TextStyle(
                        fontSize: 28,
                        fontWeight: FontWeight.bold,
                        color: textBlack,
                      ),
                    ),
                    const SizedBox(height: 30),

                    if (_errorMessage != null)
                      Padding(
                        padding: const EdgeInsets.only(bottom: 15.0),
                        child: Text(
                          _errorMessage!,
                          style: TextStyle(color: Theme.of(context).colorScheme.error, fontSize: 14),
                          textAlign: TextAlign.center,
                        ),
                      ),

                    // Email Field
                    TextFormField(
                      controller: _emailController,
                      decoration: InputDecoration(
                        hintText: 'Email',
                        prefixIcon: const Icon(Icons.email_outlined, color: textGrey),
                        filled: true,
                        fillColor: Colors.white.withOpacity(0.9),
                        border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(12.0),
                          borderSide: BorderSide.none,
                        ),
                        focusedBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(12.0),
                          borderSide: const BorderSide(color: primaryOrange, width: 1.5),
                        ),
                        contentPadding: const EdgeInsets.symmetric(vertical: 16.0, horizontal: 20.0),
                      ),
                      keyboardType: TextInputType.emailAddress,
                      style: const TextStyle(color: textBlack),
                      validator: (value) {
                        if (value == null || value.trim().isEmpty) return 'Please enter your email';
                        if (!value.contains('@') || !value.contains('.')) return 'Please enter a valid email';
                        return null;
                      },
                    ),
                    const SizedBox(height: 16),

                    // Password Field
                    TextFormField(
                      controller: _passwordController,
                      decoration: InputDecoration(
                        hintText: 'Password',
                        prefixIcon: const Icon(Icons.lock_outline, color: textGrey),
                        filled: true,
                        fillColor: Colors.white.withOpacity(0.9),
                        border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(12.0),
                          borderSide: BorderSide.none,
                        ),
                        focusedBorder: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(12.0),
                          borderSide: const BorderSide(color: primaryOrange, width: 1.5),
                        ),
                        contentPadding: const EdgeInsets.symmetric(vertical: 16.0, horizontal: 20.0),
                      ),
                      obscureText: true,
                      style: const TextStyle(color: textBlack),
                      validator: (value) {
                        if (value == null || value.isEmpty) return 'Please enter your password';
                        if (!_isLogin && value.length < 6) return 'Password must be at least 6 characters';
                        return null;
                      },
                    ),
                    const SizedBox(height: 24),

                    // Submit Button
                    if (_isLoading)
                      const Center(child: CircularProgressIndicator(color: primaryOrange))
                    else
                      ElevatedButton(
                        style: ElevatedButton.styleFrom(
                          backgroundColor: primaryOrange,
                          padding: const EdgeInsets.symmetric(vertical: 16.0),
                          shape: RoundedRectangleBorder(
                            borderRadius: BorderRadius.circular(12.0),
                          ),
                          elevation: 3,
                        ),
                        onPressed: _submitForm,
                        child: Text(
                          _isLogin ? 'Sign In' : 'Create Account',
                          style: const TextStyle(fontSize: 16, color: Colors.white, fontWeight: FontWeight.w600),
                        ),
                      ),
                    const SizedBox(height: 16),

                    // Google Sign In Button
                    ElevatedButton.icon(
                      icon: Image.asset('assets/images/google_logo.png', height: 22.0),
                      label: const Text(
                        'Sign in with Google',
                        style: TextStyle(color: textBlack, fontWeight: FontWeight.w500),
                      ),
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.white,
                        foregroundColor: textBlack,
                        padding: const EdgeInsets.symmetric(vertical: 14.0),
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(12.0),
                          side: BorderSide(color: Colors.grey.shade300),
                        ),
                        elevation: 1,
                      ),
                      onPressed: _isLoading ? null : _signInWithGoogle,
                    ),
                    const SizedBox(height: 24),

                    // Switch to Sign Up/Sign In
                    TextButton(
                      onPressed: _isLoading ? null : () {
                        setState(() {
                          _isLogin = !_isLogin;
                          _errorMessage = null;
                          _formKey.currentState?.reset();
                          _emailController.clear();
                          _passwordController.clear();
                        });
                      },
                      child: Text(
                        _isLogin ? 'Don\'t have an account? Sign Up' : 'Already have an account? Sign In',
                        style: const TextStyle(
                          color: primaryOrange,
                          fontWeight: FontWeight.w600,
                        ),
                      ),
                    ),
                     const SizedBox(height: 20), // Додатковий відступ знизу, якщо потрібно
                  ],
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}
--------------------------------------------------
=== END OF FILE: lib/login_page.dart ===


=== FILE: lib/main.dart ===
--------------------------------------------------
import 'package:flutter/material.dart';
import 'package:firebase_core/firebase_core.dart';
import 'firebase_options.dart';
import 'auth_gate.dart'; // Переконайся, що цей файл існує

void main() async {
  WidgetsFlutterBinding.ensureInitialized();
  await Firebase.initializeApp(
    options: DefaultFirebaseOptions.currentPlatform,
  );
  runApp(const MainApp());
}

class MainApp extends StatelessWidget {
  const MainApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      title: 'Muscle UP Auth', // Можеш додати назву
      theme: ThemeData( // Базова тема
        primarySwatch: Colors.deepPurple, // Або будь-який інший колір
        useMaterial3: true, // Для використання Material 3 дизайну
        inputDecorationTheme: const InputDecorationTheme( // Глобальний стиль для полів вводу
          border: OutlineInputBorder(
            borderRadius: BorderRadius.all(Radius.circular(8.0)),
          ),
        ),
        elevatedButtonTheme: ElevatedButtonThemeData( // Глобальний стиль для кнопок
          style: ElevatedButton.styleFrom(
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(8.0),
            ),
            padding: const EdgeInsets.symmetric(horizontal: 30, vertical: 15),
          ),
        ),
      ),
      home: const AuthGate(), // Використовуємо AuthGate
    );
  }
}
--------------------------------------------------
=== END OF FILE: lib/main.dart ===


=== FILE: lib/core/domain/entities/predefined_exercise.dart ===
--------------------------------------------------
// lib/core/domain/entities/predefined_exercise.dart
import 'package:cloud_firestore/cloud_firestore.dart';

class PredefinedExercise {
  final String id;
  final String name;
  final String normalizedName;
  final String primaryMuscleGroup;
  final List<String> secondaryMuscleGroups;
  final List<String> equipmentNeeded;
  final String description;
  final String? videoDemonstrationUrl;
  final String difficultyLevel;
  final List<String> tags;

  PredefinedExercise({
    required this.id,
    required this.name,
    required this.normalizedName,
    required this.primaryMuscleGroup,
    required this.secondaryMuscleGroups,
    required this.equipmentNeeded,
    required this.description,
    this.videoDemonstrationUrl,
    required this.difficultyLevel,
    required this.tags,
  });

  factory PredefinedExercise.fromFirestore(DocumentSnapshot<Map<String, dynamic>> snapshot) {
    final data = snapshot.data();
    if (data == null) throw Exception("Exercise data is null!");
    return PredefinedExercise(
      id: snapshot.id,
      name: data['name'] ?? '',
      normalizedName: data['normalizedName'] ?? '',
      primaryMuscleGroup: data['primaryMuscleGroup'] ?? '',
      secondaryMuscleGroups: List<String>.from(data['secondaryMuscleGroups'] ?? []),
      equipmentNeeded: List<String>.from(data['equipmentNeeded'] ?? []),
      description: data['description'] ?? '',
      videoDemonstrationUrl: data['videoDemonstrationUrl'],
      difficultyLevel: data['difficultyLevel'] ?? '',
      tags: List<String>.from(data['tags'] ?? []),
    );
  }

  Map<String, dynamic> toJson() { // Необхідно для адмін-панелі або майбутнього створення вправ з додатку
    return {
      'name': name,
      'normalizedName': normalizedName,
      'primaryMuscleGroup': primaryMuscleGroup,
      'secondaryMuscleGroups': secondaryMuscleGroups,
      'equipmentNeeded': equipmentNeeded,
      'description': description,
      'videoDemonstrationUrl': videoDemonstrationUrl,
      'difficultyLevel': difficultyLevel,
      'tags': tags,
    };
  }
}
--------------------------------------------------
=== END OF FILE: lib/core/domain/entities/predefined_exercise.dart ===


=== FILE: lib/core/domain/entities/routine.dart ===
--------------------------------------------------
// lib/core/domain/entities/routine.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:equatable/equatable.dart'; // Додай, якщо ще не маєш, для порівняння

// --- RoutineExercise ---
class RoutineExercise extends Equatable { // Зробимо Equatable для зручності
  final String predefinedExerciseId;
  final String exerciseNameSnapshot;
  final int numberOfSets;
  final String? notes;

  const RoutineExercise({ // Додай const
    required this.predefinedExerciseId,
    required this.exerciseNameSnapshot,
    required this.numberOfSets,
    this.notes,
  });

  factory RoutineExercise.fromMap(Map<String, dynamic> map) {
    return RoutineExercise(
      predefinedExerciseId: map['predefinedExerciseId'] ?? '',
      exerciseNameSnapshot: map['exerciseNameSnapshot'] ?? '',
      numberOfSets: map['numberOfSets'] is String
          ? int.tryParse(map['numberOfSets']) ?? 0
          : map['numberOfSets'] ?? 0, // Обробка, якщо numberOfSets приходить як String
      notes: map['notes'],
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'predefinedExerciseId': predefinedExerciseId,
      'exerciseNameSnapshot': exerciseNameSnapshot,
      'numberOfSets': numberOfSets,
      'notes': notes,
    };
  }

  RoutineExercise copyWith({
    String? predefinedExerciseId,
    String? exerciseNameSnapshot,
    int? numberOfSets,
    String? notes, // Nullable для скидання значення
    bool allowNullNotes = false, // Прапорець для дозволу встановлення notes в null
  }) {
    return RoutineExercise(
      predefinedExerciseId: predefinedExerciseId ?? this.predefinedExerciseId,
      exerciseNameSnapshot: exerciseNameSnapshot ?? this.exerciseNameSnapshot,
      numberOfSets: numberOfSets ?? this.numberOfSets,
      notes: allowNullNotes ? notes : (notes ?? this.notes),
    );
  }

  @override
  List<Object?> get props => [predefinedExerciseId, exerciseNameSnapshot, numberOfSets, notes];
}

// --- UserRoutine ---
class UserRoutine extends Equatable { // Зробимо Equatable
  final String id;
  final String userId;
  final String name;
  final String? description;
  final List<RoutineExercise> exercises;
  final List<String> scheduledDays;
  final bool isPublic;
  // Додай інші поля згідно з дизайн-документом (communityRatingSum і т.д.)
  final Timestamp createdAt;
  final Timestamp updatedAt;

  const UserRoutine({ // Додай const
    required this.id,
    required this.userId,
    required this.name,
    this.description,
    required this.exercises,
    required this.scheduledDays,
    this.isPublic = false,
    required this.createdAt,
    required this.updatedAt,
  });

  factory UserRoutine.fromFirestore(DocumentSnapshot<Map<String, dynamic>> snapshot) {
    final data = snapshot.data();
    if (data == null) throw Exception("Routine data is null!");
    return UserRoutine(
      id: snapshot.id,
      userId: data['userId'] ?? '',
      name: data['name'] ?? '',
      description: data['description'],
      exercises: (data['exercises'] as List<dynamic>?)
              ?.map((e) => RoutineExercise.fromMap(e as Map<String, dynamic>))
              .toList() ??
          [],
      scheduledDays: List<String>.from(data['scheduledDays'] ?? []),
      isPublic: data['isPublic'] ?? false,
      // Важливо правильно обробляти Timestamps
      createdAt: data['createdAt'] is Timestamp ? data['createdAt'] : Timestamp.now(),
      updatedAt: data['updatedAt'] is Timestamp ? data['updatedAt'] : Timestamp.now(),
    );
  }

  Map<String, dynamic> toMap() {
    return {
      'userId': userId,
      'name': name,
      'description': description,
      'exercises': exercises.map((e) => e.toMap()).toList(),
      'scheduledDays': scheduledDays,
      'isPublic': isPublic,
      // createdAt та updatedAt краще встановлювати через FieldValue.serverTimestamp() при записі
      // 'createdAt': createdAt, // Закоментуй, якщо встановлюєш через FieldValue
      // 'updatedAt': updatedAt, // Закоментуй, якщо встановлюєш через FieldValue
      // Додай інші поля
    };
  }

  UserRoutine copyWith({
    String? id,
    String? userId,
    String? name,
    String? description, // Nullable для скидання
    List<RoutineExercise>? exercises,
    List<String>? scheduledDays,
    bool? isPublic,
    Timestamp? createdAt,
    Timestamp? updatedAt,
    bool allowNullDescription = false, // Прапорець для дозволу встановлення description в null
  }) {
    return UserRoutine(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      name: name ?? this.name,
      description: allowNullDescription ? description : (description ?? this.description),
      exercises: exercises ?? this.exercises,
      scheduledDays: scheduledDays ?? this.scheduledDays,
      isPublic: isPublic ?? this.isPublic,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  List<Object?> get props => [
        id,
        userId,
        name,
        description,
        exercises,
        scheduledDays,
        isPublic,
        createdAt,
        updatedAt
      ];
}
--------------------------------------------------
=== END OF FILE: lib/core/domain/entities/routine.dart ===


=== FILE: lib/core/domain/repositories/predefined_exercise_repository.dart ===
--------------------------------------------------
// lib/core/domain/repositories/predefined_exercise_repository.dart
import '../entities/predefined_exercise.dart';

abstract class PredefinedExerciseRepository {
  Future<List<PredefinedExercise>> getAllExercises();
  // В майбутньому: Future<List<PredefinedExercise>> searchExercises(String query);
  // В майбутньому: Future<List<PredefinedExercise>> filterExercises(Map<String, dynamic> filters);
}
--------------------------------------------------
=== END OF FILE: lib/core/domain/repositories/predefined_exercise_repository.dart ===


=== FILE: lib/core/domain/repositories/routine_repository.dart ===
--------------------------------------------------
// lib/core/domain/repositories/routine_repository.dart
import '../entities/routine.dart'; // Перевір цей імпорт також

abstract class RoutineRepository { // <-- Ключове слово "abstract class"
  Future<void> createRoutine(UserRoutine routine);
  Future<List<UserRoutine>> getUserRoutines(String userId);
  Future<void> updateRoutine(UserRoutine routine);
  Future<void> deleteRoutine(String routineId);
}
--------------------------------------------------
=== END OF FILE: lib/core/domain/repositories/routine_repository.dart ===


=== FILE: lib/features/exercise_explorer/data/repositories/predefined_exercise_repository_impl.dart ===
--------------------------------------------------
// lib/features/exercise_explorer/data/repositories/predefined_exercise_repository_impl.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import '../../../../core/domain/entities/predefined_exercise.dart';
import '../../../../core/domain/repositories/predefined_exercise_repository.dart';
import 'dart:developer' as developer; // Для логування


class PredefinedExerciseRepositoryImpl implements PredefinedExerciseRepository {
  final FirebaseFirestore _firestore;

  PredefinedExerciseRepositoryImpl({FirebaseFirestore? firestore})
      : _firestore = firestore ?? FirebaseFirestore.instance;

  @override
  Future<List<PredefinedExercise>> getAllExercises() async {
    try {
      final snapshot = await _firestore.collection('predefinedExercises').orderBy('name').get(); // Сортуємо за назвою
      return snapshot.docs
          .map((doc) => PredefinedExercise.fromFirestore(doc as DocumentSnapshot<Map<String, dynamic>>))
          .toList();
    } catch (e) {
      developer.log("Error fetching exercises: $e", name: "PredefinedExerciseRepo");
      throw Exception('Failed to fetch predefined exercises.');
    }
  }
}
--------------------------------------------------
=== END OF FILE: lib/features/exercise_explorer/data/repositories/predefined_exercise_repository_impl.dart ===


=== FILE: lib/features/exercise_explorer/data/repositories/routine_repository_impl.dart ===
--------------------------------------------------
// lib/features/routines/data/repositories/routine_repository_impl.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart'; // Для отримання поточного userId
import '../../../../core/domain/entities/routine.dart';
import '../../../../core/domain/repositories/routine_repository.dart';

class RoutineRepositoryImpl implements RoutineRepository {
  final FirebaseFirestore _firestore;
  final FirebaseAuth _firebaseAuth; // Додано

  RoutineRepositoryImpl({FirebaseFirestore? firestore, FirebaseAuth? firebaseAuth}) // Оновлено
    : _firestore = firestore ?? FirebaseFirestore.instance,
      _firebaseAuth = firebaseAuth ?? FirebaseAuth.instance; // Оновлено

  @override
  Future<void> createRoutine(UserRoutine routine) async {
    try {
      final docRef = _firestore.collection('userRoutines').doc();
      // Встановлюємо createdAt та updatedAt на серверний час при створенні
      final routineData = routine.toMap()
        ..['createdAt'] = FieldValue.serverTimestamp()
        ..['updatedAt'] = FieldValue.serverTimestamp();
      await docRef.set(routineData);
    } catch (e) {
      print("Error creating routine: $e");
      throw Exception('Failed to create routine.');
    }
  }

  @override
  Future<List<UserRoutine>> getUserRoutines(String userId) async {
    try {
      final snapshot = await _firestore
          .collection('userRoutines')
          .where('userId', isEqualTo: userId)
          .orderBy('createdAt', descending: true) // Сортування за датою створення
          .get();
      return snapshot.docs
          .map((doc) => UserRoutine.fromFirestore(doc as DocumentSnapshot<Map<String, dynamic>>))
          .toList();
    } catch (e) {
      print("Error fetching user routines: $e");
      throw Exception('Failed to fetch user routines.');
    }
  }

  @override
  Future<void> updateRoutine(UserRoutine routine) async {
    try {
      final routineData = routine.toMap()..['updatedAt'] = FieldValue.serverTimestamp();
      await _firestore.collection('userRoutines').doc(routine.id).update(routineData);
    } catch (e) {
      print("Error updating routine: $e");
      throw Exception('Failed to update routine.');
    }
  }

  @override
  Future<void> deleteRoutine(String routineId) async {
    try {
      await _firestore.collection('userRoutines').doc(routineId).delete();
    } catch (e) {
      print("Error deleting routine: $e");
      throw Exception('Failed to delete routine.');
    }
  }
}
--------------------------------------------------
=== END OF FILE: lib/features/exercise_explorer/data/repositories/routine_repository_impl.dart ===


=== FILE: lib/features/exercise_explorer/presentation/cubit/exercise_explorer_cubit.dart ===
--------------------------------------------------
// lib/features/exercise_explorer/presentation/cubit/exercise_explorer_cubit.dart
import 'package:bloc/bloc.dart';
import 'package:equatable/equatable.dart';
import '../../../../core/domain/entities/predefined_exercise.dart';
import '../../../../core/domain/repositories/predefined_exercise_repository.dart'; // Абстракція

part 'exercise_explorer_state.dart';

class ExerciseExplorerCubit extends Cubit<ExerciseExplorerState> {
  final PredefinedExerciseRepository _exerciseRepository;

  ExerciseExplorerCubit(this._exerciseRepository) : super(ExerciseExplorerInitial());

  Future<void> fetchExercises() async {
    emit(ExerciseExplorerLoading());
    try {
      final exercises = await _exerciseRepository.getAllExercises();
      emit(ExerciseExplorerLoaded(exercises));
    } catch (e) {
      emit(ExerciseExplorerError(e.toString()));
    }
  }
}
--------------------------------------------------
=== END OF FILE: lib/features/exercise_explorer/presentation/cubit/exercise_explorer_cubit.dart ===


=== FILE: lib/features/exercise_explorer/presentation/cubit/exercise_explorer_state.dart ===
--------------------------------------------------
// lib/features/exercise_explorer/presentation/cubit/exercise_explorer_state.dart
part of 'exercise_explorer_cubit.dart';

abstract class ExerciseExplorerState extends Equatable {
  const ExerciseExplorerState();
  @override
  List<Object?> get props => [];
}

class ExerciseExplorerInitial extends ExerciseExplorerState {}
class ExerciseExplorerLoading extends ExerciseExplorerState {}
class ExerciseExplorerLoaded extends ExerciseExplorerState {
  final List<PredefinedExercise> exercises;
  const ExerciseExplorerLoaded(this.exercises);
  @override
  List<Object?> get props => [exercises];
}
class ExerciseExplorerError extends ExerciseExplorerState {
  final String message;
  const ExerciseExplorerError(this.message);
  @override
  List<Object?> get props => [message];
}
--------------------------------------------------
=== END OF FILE: lib/features/exercise_explorer/presentation/cubit/exercise_explorer_state.dart ===


=== FILE: lib/features/exercise_explorer/presentation/screens/exercise_explorer_screen.dart ===
--------------------------------------------------
// lib/features/exercise_explorer/presentation/screens/exercise_explorer_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import '../cubit/exercise_explorer_cubit.dart';
import '../../data/repositories/predefined_exercise_repository_impl.dart'; // Тимчасово для простоти, краще через DI
// import '../../../../core/domain/entities/predefined_exercise.dart'; // Перевірити, чи потрібен після змін
import '../widgets/exercise_list_item.dart';

class ExerciseExplorerScreen extends StatelessWidget {
  final bool isSelectionMode; // <--- ДОДАНО

  const ExerciseExplorerScreen({super.key, this.isSelectionMode = false}); // <--- ДОДАНО

  @override
  Widget build(BuildContext context) {
    return BlocProvider(
      create: (context) => ExerciseExplorerCubit(
        // Переконайся, що PredefinedExerciseRepositoryImpl() передається коректно
        // або використовуй RepositoryProvider.of<PredefinedExerciseRepository>(context)
        PredefinedExerciseRepositoryImpl() 
      )..fetchExercises(),
      child: Scaffold(
        appBar: AppBar(
          title: Text(isSelectionMode ? 'Select Exercise' : 'Exercise Library'),
          // Якщо в режимі вибору, можна не показувати кнопку назад, якщо це модальне вікно
          // automaticallyImplyLeading: !isSelectionMode, 
        ),
        body: BlocBuilder<ExerciseExplorerCubit, ExerciseExplorerState>(
          builder: (context, state) {
            if (state is ExerciseExplorerLoading) {
              return const Center(child: CircularProgressIndicator());
            } else if (state is ExerciseExplorerLoaded) {
              if (state.exercises.isEmpty) {
                return const Center(child: Text('No exercises found.'));
              }
              return ListView.builder(
                itemCount: state.exercises.length,
                itemBuilder: (context, index) {
                  final exercise = state.exercises[index];
                  return ExerciseListItem(
                    exercise: exercise, 
                    isSelectionMode: isSelectionMode, // <--- ПЕРЕДАНО
                  );
                },
              );
            } else if (state is ExerciseExplorerError) {
              return Center(child: Text('Error: ${state.message}'));
            }
            // Початковий стан або якщо щось не так
            return const Center(child: Text('Loading exercises...'));
          },
        ),
      ),
    );
  }
}
--------------------------------------------------
=== END OF FILE: lib/features/exercise_explorer/presentation/screens/exercise_explorer_screen.dart ===


=== FILE: lib/features/exercise_explorer/presentation/widgets/exercise_list_item.dart ===
--------------------------------------------------
// lib/features/exercise_explorer/presentation/widgets/exercise_list_item.dart
import 'package:flutter/material.dart';
import '../../../../core/domain/entities/predefined_exercise.dart';

class ExerciseListItem extends StatelessWidget {
  final PredefinedExercise exercise;
  final bool isSelectionMode; // <--- ДОДАНО

  const ExerciseListItem({
    super.key, 
    required this.exercise,
    this.isSelectionMode = false, // <--- ДОДАНО
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: ListTile(
        title: Text(exercise.name),
        subtitle: Text(exercise.primaryMuscleGroup),
        trailing: isSelectionMode ? const Icon(Icons.add_circle_outline) : const Icon(Icons.arrow_forward_ios),
        onTap: () {
          if (isSelectionMode) {
            Navigator.pop(context, exercise); // Повертаємо обрану вправу
          } else {
            // TODO: Навігація на детальний екран вправи
            // Наприклад: Navigator.push(context, MaterialPageRoute(builder: (_) => ExerciseDetailScreen(exercise: exercise)));
            // log('Tapped on ${exercise.name} for details'); // Використовуй логгер
          }
        },
      ),
    );
  }
}
--------------------------------------------------
=== END OF FILE: lib/features/exercise_explorer/presentation/widgets/exercise_list_item.dart ===


=== FILE: lib/features/routines/data/repositories/routine_repository_impl.dart ===
--------------------------------------------------
// lib/features/routines/data/repositories/routine_repository_impl.dart
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../../../../core/domain/entities/routine.dart';
import '../../../../core/domain/repositories/routine_repository.dart';
import 'dart:developer' as developer; // Для логування

class RoutineRepositoryImpl implements RoutineRepository {
  final FirebaseFirestore _firestore;
  final FirebaseAuth _firebaseAuth; // ЗАЛИШАЄМО, бо використовується для _currentUserId

  RoutineRepositoryImpl({FirebaseFirestore? firestore, FirebaseAuth? firebaseAuth})
      : _firestore = firestore ?? FirebaseFirestore.instance,
        _firebaseAuth = firebaseAuth ?? FirebaseAuth.instance;

  String? get _currentUserId => _firebaseAuth.currentUser?.uid; // Використовується

  @override
  Future<void> createRoutine(UserRoutine routine) async {
    final currentUserId = _currentUserId; // Зберігаємо в локальну змінну
    if (currentUserId == null) throw Exception('User not logged in');
    try {
      final docRef = _firestore.collection('userRoutines').doc();
      final routineData = routine.copyWith(
        id: docRef.id,
        userId: currentUserId, // Гарантуємо правильний userId
        createdAt: Timestamp.now(), 
        updatedAt: Timestamp.now()
      ).toMap()
        ..['createdAt'] = FieldValue.serverTimestamp()
        ..['updatedAt'] = FieldValue.serverTimestamp();
      await docRef.set(routineData);
    } catch (e) {
      developer.log("Error creating routine: $e", name: "RoutineRepositoryImpl");
      throw Exception('Failed to create routine.');
    }
  }

  @override
  Future<List<UserRoutine>> getUserRoutines(String userId) async {
    if (userId.isEmpty) throw Exception('User ID cannot be empty');
    try {
      final snapshot = await _firestore
          .collection('userRoutines')
          .where('userId', isEqualTo: userId)
          .orderBy('updatedAt', descending: true)
          .get();
      return snapshot.docs
          .map((doc) => UserRoutine.fromFirestore(doc as DocumentSnapshot<Map<String, dynamic>>))
          .toList();
    } catch (e) {
      developer.log("Error fetching user routines for $userId: $e", name: "RoutineRepositoryImpl");
      throw Exception('Failed to fetch user routines.');
    }
  }

  @override
  Future<void> updateRoutine(UserRoutine routine) async {
    final currentUserId = _currentUserId;
    if (currentUserId == null) throw Exception('User not logged in');
    if (routine.userId != currentUserId) throw Exception('Cannot update routine of another user');
    try {
      final routineData = routine.copyWith(updatedAt: Timestamp.now()).toMap()
        ..['updatedAt'] = FieldValue.serverTimestamp();
      await _firestore.collection('userRoutines').doc(routine.id).update(routineData);
    } catch (e) {
      developer.log("Error updating routine ${routine.id}: $e", name: "RoutineRepositoryImpl");
      throw Exception('Failed to update routine.');
    }
  }

  @override
  Future<void> deleteRoutine(String routineId) async {
    final currentUserId = _currentUserId;
    if (currentUserId == null) throw Exception('User not logged in');
    try {
      final routineDoc = await _firestore.collection('userRoutines').doc(routineId).get();
      if (!routineDoc.exists || routineDoc.data()?['userId'] != currentUserId) {
        developer.log('Attempt to delete routine $routineId failed: Not found or permission denied.', name: "RoutineRepositoryImpl");
        throw Exception('Routine not found or permission denied to delete.');
      }
      await _firestore.collection('userRoutines').doc(routineId).delete();
    } catch (e) {
      developer.log("Error deleting routine $routineId: $e", name: "RoutineRepositoryImpl");
      // Не перезагортаємо у загальний Exception, якщо це вже специфічний
      if (e is! Exception || !e.toString().contains('Routine not found')) {
          throw Exception('Failed to delete routine.');
      }
      rethrow; // Перекидаємо оригінальну помилку, якщо це "Routine not found..."
    }
  }
}
--------------------------------------------------
=== END OF FILE: lib/features/routines/data/repositories/routine_repository_impl.dart ===


=== FILE: lib/features/routines/presentation/cubit/manage_routine_cubit.dart ===
--------------------------------------------------
// lib/features/routines/presentation/cubit/manage_routine_cubit.dart
import 'package:bloc/bloc.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:equatable/equatable.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../../../../core/domain/entities/routine.dart';
import '../../../../core/domain/repositories/routine_repository.dart';

part 'manage_routine_state.dart';

class ManageRoutineCubit extends Cubit<ManageRoutineState> {
  final RoutineRepository _routineRepository;
  final FirebaseAuth _firebaseAuth;
  UserRoutine _currentRoutine; // Внутрішній стан рутини, що редагується
  final bool _isEditing;

  ManageRoutineCubit(
    this._routineRepository,
    this._firebaseAuth, {
    UserRoutine? initialRoutine,
  })  : _currentRoutine = initialRoutine ??
            UserRoutine(
              // Значення за замовчуванням для нової рутини
              id: '', // Буде встановлено репозиторієм
              userId: _firebaseAuth.currentUser?.uid ?? '',
              name: '',
              exercises: [],
              scheduledDays: [],
              isPublic: false,
              createdAt: Timestamp.now(), // Попереднє значення
              updatedAt: Timestamp.now(), // Попереднє значення
            ),
        _isEditing = initialRoutine != null,
        super(ManageRoutineInitial(
            routine: initialRoutine ??
                UserRoutine(
                  id: '',
                  userId: _firebaseAuth.currentUser?.uid ?? '',
                  name: '',
                  exercises: [],
                  scheduledDays: [],
                  isPublic: false,
                  createdAt: Timestamp.now(),
                  updatedAt: Timestamp.now(),
                ),
            isEditing: initialRoutine != null));

  UserRoutine get currentRoutineSnapshot => _currentRoutine;
  bool get isEditingMode => _isEditing;

  void updateRoutineName(String name) {
    _currentRoutine = _currentRoutine.copyWith(name: name);
    emit(ManageRoutineExercisesUpdated(_currentRoutine)); // Щоб UI оновився
  }

  void updateRoutineDescription(String description) {
    _currentRoutine = _currentRoutine.copyWith(description: description);
     emit(ManageRoutineExercisesUpdated(_currentRoutine));
  }

  void updateScheduledDays(List<String> days) {
    _currentRoutine = _currentRoutine.copyWith(scheduledDays: days);
     emit(ManageRoutineExercisesUpdated(_currentRoutine));
  }

  void addExerciseToRoutine(RoutineExercise exercise) {
    final updatedExercises = List<RoutineExercise>.from(_currentRoutine.exercises)..add(exercise);
    _currentRoutine = _currentRoutine.copyWith(exercises: updatedExercises);
    emit(ManageRoutineExercisesUpdated(_currentRoutine));
  }

  void updateExerciseInRoutine(int index, RoutineExercise exercise) {
    if (index < 0 || index >= _currentRoutine.exercises.length) return;
    final updatedExercises = List<RoutineExercise>.from(_currentRoutine.exercises);
    updatedExercises[index] = exercise;
    _currentRoutine = _currentRoutine.copyWith(exercises: updatedExercises);
    emit(ManageRoutineExercisesUpdated(_currentRoutine));
  }

  void removeExerciseFromRoutine(int index) {
    if (index < 0 || index >= _currentRoutine.exercises.length) return;
    final updatedExercises = List<RoutineExercise>.from(_currentRoutine.exercises)..removeAt(index);
    _currentRoutine = _currentRoutine.copyWith(exercises: updatedExercises);
    emit(ManageRoutineExercisesUpdated(_currentRoutine));
  }

  Future<void> saveRoutine() async {
    final userId = _firebaseAuth.currentUser?.uid;
    if (userId == null) {
      emit(const ManageRoutineFailure("User not logged in."));
      return;
    }
    if (_currentRoutine.name.trim().isEmpty) {
      emit(const ManageRoutineFailure("Routine name cannot be empty."));
      return;
    }
    if (_currentRoutine.exercises.isEmpty) {
      emit(const ManageRoutineFailure("Routine must have at least one exercise."));
      return;
    }

    emit(const ManageRoutineLoading(loadingMessage: "Saving routine..."));
    
    // Оновлюємо userId та timestamps перед збереженням
    _currentRoutine = _currentRoutine.copyWith(
        userId: userId, 
        // createdAt тут не оновлюємо, якщо isEditing, timestamp оновлюється в репо
        updatedAt: Timestamp.now(), // оновлюємо локально для консистентності
    );

    try {
      if (_isEditing) {
        await _routineRepository.updateRoutine(_currentRoutine);
        emit(ManageRoutineSuccess("Routine updated successfully!", _currentRoutine));
      } else {
        // Для нової рутини ID буде присвоєно в репозиторії,
        // але ми можемо створити тимчасовий локальний ID або чекати на повернення з репозиторію.
        // Краще, щоб репозиторій повертав створений об'єкт або його ID.
        // Наразі, припустимо, що репозиторій обробляє ID.
        // Або, якщо `createRoutine` повертає `UserRoutine`:
        // final savedRoutine = await _routineRepository.createRoutine(_currentRoutine);
        // emit(ManageRoutineSuccess("Routine created successfully!", savedRoutine));
        
        // Поточна реалізація createRoutine не повертає об'єкт, тому ми просто
        // передаємо _currentRoutine, припускаючи, що ID буде встановлено в Firestore
        // і для наступного завантаження воно буде коректним.
        await _routineRepository.createRoutine(_currentRoutine);
        emit(ManageRoutineSuccess("Routine created successfully!", _currentRoutine));
      }
    } catch (e) {
      emit(ManageRoutineFailure(e.toString().replaceFirst("Exception: ", "")));
    }
  }

   Future<void> deleteRoutine() async {
    if (!_isEditing || _currentRoutine.id.isEmpty) {
      emit(const ManageRoutineFailure("Cannot delete a new or unsaved routine."));
      return;
    }
     final userId = _firebaseAuth.currentUser?.uid;
    if (userId == null) {
      emit(const ManageRoutineFailure("User not logged in."));
      return;
    }

    emit(const ManageRoutineLoading(loadingMessage: "Deleting routine..."));
    try {
      await _routineRepository.deleteRoutine(_currentRoutine.id);
      emit(ManageRoutineSuccess("Routine deleted successfully!", _currentRoutine)); // Повертаємо видалену рутину для обробки в UI
    } catch (e) {
      emit(ManageRoutineFailure(e.toString().replaceFirst("Exception: ", "")));
    }
  }
}
--------------------------------------------------
=== END OF FILE: lib/features/routines/presentation/cubit/manage_routine_cubit.dart ===


=== FILE: lib/features/routines/presentation/cubit/manage_routine_state.dart ===
--------------------------------------------------
// lib/features/routines/presentation/cubit/manage_routine_state.dart
part of 'manage_routine_cubit.dart';

abstract class ManageRoutineState extends Equatable {
  const ManageRoutineState();

  @override
  List<Object?> get props => [];
}

class ManageRoutineInitial extends ManageRoutineState {
  final UserRoutine routine; // Поточний стан рутини, що редагується/створюється
  final bool isEditing;

  const ManageRoutineInitial({required this.routine, this.isEditing = false});

  @override
  List<Object?> get props => [routine, isEditing];
}

class ManageRoutineLoading extends ManageRoutineState {
    final String? loadingMessage;
    const ManageRoutineLoading({this.loadingMessage});

    @override
    List<Object?> get props => [loadingMessage];
}

class ManageRoutineSuccess extends ManageRoutineState {
  final String message;
  final UserRoutine savedRoutine; // Повертаємо збережену рутину

  const ManageRoutineSuccess(this.message, this.savedRoutine);

  @override
  List<Object?> get props => [message, savedRoutine];
}

class ManageRoutineFailure extends ManageRoutineState {
  final String error;

  const ManageRoutineFailure(this.error);

  @override
  List<Object?> get props => [error];
}

// Додатковий стан для оновлення UI при зміні вправ у рутині
class ManageRoutineExercisesUpdated extends ManageRoutineState {
  final UserRoutine updatedRoutine;

  const ManageRoutineExercisesUpdated(this.updatedRoutine);

   @override
  List<Object?> get props => [updatedRoutine];
}
--------------------------------------------------
=== END OF FILE: lib/features/routines/presentation/cubit/manage_routine_state.dart ===


=== FILE: lib/features/routines/presentation/cubit/user_routines_cubit.dart ===
--------------------------------------------------
// lib/features/routines/presentation/cubit/user_routines_cubit.dart
import 'package:bloc/bloc.dart';
import 'package:equatable/equatable.dart';
import 'package:firebase_auth/firebase_auth.dart'; // Для отримання UID
import '../../../../core/domain/entities/routine.dart';
import '../../../../core/domain/repositories/routine_repository.dart';

part 'user_routines_state.dart';

class UserRoutinesCubit extends Cubit<UserRoutinesState> {
  final RoutineRepository _routineRepository;
  final FirebaseAuth _firebaseAuth; // Для отримання UID

  UserRoutinesCubit(this._routineRepository, this._firebaseAuth) : super(UserRoutinesInitial());

  Future<void> fetchUserRoutines() async {
    final userId = _firebaseAuth.currentUser?.uid;
    if (userId == null) {
      emit(const UserRoutinesError("User not logged in. Cannot fetch routines."));
      return;
    }

    emit(UserRoutinesLoading());
    try {
      final routines = await _routineRepository.getUserRoutines(userId);
      emit(UserRoutinesLoaded(routines));
    } catch (e) {
      emit(UserRoutinesError(e.toString().replaceFirst("Exception: ", "")));
    }
  }

  // Метод для оновлення списку після видалення рутини
  void routineDeleted(String routineId) {
    if (state is UserRoutinesLoaded) {
      final currentState = state as UserRoutinesLoaded;
      final updatedRoutines = currentState.routines.where((r) => r.id != routineId).toList();
      emit(UserRoutinesLoaded(updatedRoutines));
    }
  }
   // Метод для оновлення списку після додавання/редагування рутини
  void routineAddedOrUpdated(UserRoutine routine) {
    if (state is UserRoutinesLoaded) {
      final currentState = state as UserRoutinesLoaded;
      List<UserRoutine> updatedRoutines = List.from(currentState.routines);
      final index = updatedRoutines.indexWhere((r) => r.id == routine.id);
      if (index != -1) { // Оновлення існуючої
        updatedRoutines[index] = routine;
      } else { // Додавання нової
        updatedRoutines.insert(0, routine); // Додаємо на початок для кращого UX
      }
      emit(UserRoutinesLoaded(updatedRoutines));
    } else {
      // Якщо список ще не завантажений, просто завантажуємо його знову
      fetchUserRoutines();
    }
  }
}
--------------------------------------------------
=== END OF FILE: lib/features/routines/presentation/cubit/user_routines_cubit.dart ===


=== FILE: lib/features/routines/presentation/cubit/user_routines_state.dart ===
--------------------------------------------------
// lib/features/routines/presentation/cubit/user_routines_state.dart
part of 'user_routines_cubit.dart';

abstract class UserRoutinesState extends Equatable {
  const UserRoutinesState();

  @override
  List<Object> get props => [];
}

class UserRoutinesInitial extends UserRoutinesState {}

class UserRoutinesLoading extends UserRoutinesState {}

class UserRoutinesLoaded extends UserRoutinesState {
  final List<UserRoutine> routines;

  const UserRoutinesLoaded(this.routines);

  @override
  List<Object> get props => [routines];
}

class UserRoutinesError extends UserRoutinesState {
  final String message;

  const UserRoutinesError(this.message);

  @override
  List<Object> get props => [message];
}
--------------------------------------------------
=== END OF FILE: lib/features/routines/presentation/cubit/user_routines_state.dart ===


=== FILE: lib/features/routines/presentation/screens/create_edit_routine_screen.dart ===
--------------------------------------------------
// lib/features/routines/presentation/screens/create_edit_routine_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:firebase_auth/firebase_auth.dart'; // для доступу до репо та auth
import '../../../../core/domain/entities/routine.dart';
import '../../../../core/domain/repositories/routine_repository.dart'; // для доступу до репо
import '../cubit/manage_routine_cubit.dart';
import '../cubit/user_routines_cubit.dart'; // для оновлення списку рутин
import '../widgets/add_exercise_to_routine_dialog.dart'; // Діалог, який ми щойно створили

class CreateEditRoutineScreen extends StatefulWidget {
  final UserRoutine? routineToEdit;

  const CreateEditRoutineScreen({super.key, this.routineToEdit});

  @override
  State<CreateEditRoutineScreen> createState() => _CreateEditRoutineScreenState();
}

class _CreateEditRoutineScreenState extends State<CreateEditRoutineScreen> {
  late final ManageRoutineCubit _manageRoutineCubit;
  final _formKey = GlobalKey<FormState>();
  final _nameController = TextEditingController();
  final _descriptionController = TextEditingController();
  List<String> _selectedDays = []; // Для вибору днів тижня

  final List<String> _availableDays = [
    'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT', 'SUN'
  ];

  @override
  void initState() {
    super.initState();
    _manageRoutineCubit = ManageRoutineCubit(
      RepositoryProvider.of<RoutineRepository>(context),
      FirebaseAuth.instance, // Передаємо FirebaseAuth
      initialRoutine: widget.routineToEdit,
    );

    if (widget.routineToEdit != null) {
      _nameController.text = widget.routineToEdit!.name;
      _descriptionController.text = widget.routineToEdit!.description ?? '';
      _selectedDays = List<String>.from(widget.routineToEdit!.scheduledDays);
    }

    _nameController.addListener(() {
      _manageRoutineCubit.updateRoutineName(_nameController.text);
    });
    _descriptionController.addListener(() {
      _manageRoutineCubit.updateRoutineDescription(_descriptionController.text);
    });
  }

  @override
  void dispose() {
    _nameController.dispose();
    _descriptionController.dispose();
    _manageRoutineCubit.close();
    super.dispose();
  }

  void _saveRoutine() {
    if (_formKey.currentState!.validate()) {
      // Переконуємось, що останні зміни з контролерів передані в кубіт
      _manageRoutineCubit.updateRoutineName(_nameController.text);
      _manageRoutineCubit.updateRoutineDescription(_descriptionController.text);
      _manageRoutineCubit.updateScheduledDays(_selectedDays);
      
      _manageRoutineCubit.saveRoutine();
    }
  }

  Future<void> _deleteRoutine() async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (ctx) => AlertDialog(
        title: const Text('Confirm Delete'),
        content: Text('Are you sure you want to delete "${_nameController.text}"?'),
        actions: [
          TextButton(onPressed: () => Navigator.of(ctx).pop(false), child: const Text('Cancel')),
          TextButton(
            onPressed: () => Navigator.of(ctx).pop(true),
            style: TextButton.styleFrom(foregroundColor: Colors.red),
            child: const Text('Delete'),
          ),
        ],
      ),
    );
    if (confirmed == true) {
      _manageRoutineCubit.deleteRoutine();
    }
  }


  Widget _buildExerciseItem(BuildContext context, RoutineExercise exercise, int index) {
    return Card(
      margin: const EdgeInsets.symmetric(vertical: 4),
      child: ListTile(
        title: Text(exercise.exerciseNameSnapshot),
        subtitle: Text('${exercise.numberOfSets} sets'),
        trailing: IconButton(
          icon: const Icon(Icons.delete_outline, color: Colors.redAccent),
          onPressed: () {
            _manageRoutineCubit.removeExerciseFromRoutine(index);
          },
        ),
        onTap: () async {
           // TODO: Редагування вправи в рутині (наприклад, зміна кількості підходів)
          // Можна відкрити діалог схожий на той, що використовується для додавання,
          // але з попередньо заповненими даними.
          final TextEditingController setsCtrl = TextEditingController(text: exercise.numberOfSets.toString());
          final TextEditingController notesCtrl = TextEditingController(text: exercise.notes ?? '');
          final formKey = GlobalKey<FormState>();

          final RoutineExercise? updatedExerciseDetails = await showDialog<RoutineExercise>(
            context: context,
            builder: (dialogCtx) => AlertDialog(
              title: Text('Edit "${exercise.exerciseNameSnapshot}"'),
              content: Form(
                key: formKey,
                child: Column(mainAxisSize: MainAxisSize.min, children: [
                  TextFormField(
                    controller: setsCtrl,
                    decoration: const InputDecoration(labelText: 'Number of Sets'),
                    keyboardType: TextInputType.number,
                    validator: (v) => (v == null || v.isEmpty || int.tryParse(v) == null || int.parse(v) <= 0) ? 'Invalid sets' : null,
                  ),
                  const SizedBox(height: 8),
                  TextFormField(controller: notesCtrl, decoration: const InputDecoration(labelText: 'Notes (optional)')),
                ]),
              ),
              actions: [
                TextButton(onPressed: () => Navigator.pop(dialogCtx), child: const Text('Cancel')),
                ElevatedButton(
                  onPressed: () {
                    if (formKey.currentState!.validate()) {
                       Navigator.pop(dialogCtx, RoutineExercise(
                        predefinedExerciseId: exercise.predefinedExerciseId,
                        exerciseNameSnapshot: exercise.exerciseNameSnapshot,
                        numberOfSets: int.parse(setsCtrl.text),
                        notes: notesCtrl.text.trim().isNotEmpty ? notesCtrl.text.trim() : null,
                      ));
                    }
                  },
                  child: const Text('Update'),
                ),
              ],
            ),
          );
          if (updatedExerciseDetails != null) {
            _manageRoutineCubit.updateExerciseInRoutine(index, updatedExerciseDetails);
          }
        },
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return BlocProvider.value(
      value: _manageRoutineCubit,
      child: Scaffold(
        appBar: AppBar(
          title: Text(widget.routineToEdit == null ? 'Create Routine' : 'Edit Routine'),
          actions: [
            if (widget.routineToEdit != null)
              IconButton(
                icon: const Icon(Icons.delete_forever, color: Colors.red),
                onPressed: _deleteRoutine,
                tooltip: 'Delete Routine',
              ),
            IconButton(
              icon: const Icon(Icons.save),
              onPressed: _saveRoutine,
              tooltip: 'Save Routine',
            ),
          ],
        ),
        body: BlocConsumer<ManageRoutineCubit, ManageRoutineState>(
          listener: (context, state) {
            if (state is ManageRoutineSuccess) {
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(content: Text(state.message), backgroundColor: Colors.green),
              );
              // Оновлюємо список рутин на попередньому екрані
              context.read<UserRoutinesCubit>().routineAddedOrUpdated(state.savedRoutine);

              Navigator.of(context).pop(); // Повертаємось назад після успіху
            } else if (state is ManageRoutineFailure) {
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(content: Text('Error: ${state.error}'), backgroundColor: Colors.red),
              );
            }
          },
          builder: (context, state) {
            UserRoutine currentDisplayRoutine = _manageRoutineCubit.currentRoutineSnapshot;
            if (state is ManageRoutineExercisesUpdated) { // Оновлюємо відображення, якщо вправи змінились
              currentDisplayRoutine = state.updatedRoutine;
            } else if (state is ManageRoutineInitial) {
              currentDisplayRoutine = state.routine;
            }


            if (state is ManageRoutineLoading) {
              return Center(child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  const CircularProgressIndicator(),
                  if(state.loadingMessage != null) ...[
                    const SizedBox(height: 16),
                    Text(state.loadingMessage!),
                  ]
                ],
              ));
            }

            return SingleChildScrollView(
              padding: const EdgeInsets.all(16.0),
              child: Form(
                key: _formKey,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: <Widget>[
                    TextFormField(
                      controller: _nameController,
                      decoration: const InputDecoration(labelText: 'Routine Name'),
                      validator: (value) => value == null || value.trim().isEmpty ? 'Name cannot be empty' : null,
                    ),
                    const SizedBox(height: 16),
                    TextFormField(
                      controller: _descriptionController,
                      decoration: const InputDecoration(labelText: 'Description (optional)'),
                      maxLines: 3,
                    ),
                    const SizedBox(height: 24),
                    Text('Scheduled Days:', style: Theme.of(context).textTheme.titleMedium),
                    Wrap(
                      spacing: 8.0,
                      children: _availableDays.map((day) {
                        final isSelected = _selectedDays.contains(day);
                        return FilterChip(
                          label: Text(day),
                          selected: isSelected,
                          onSelected: (bool selected) {
                            setState(() {
                              if (selected) {
                                _selectedDays.add(day);
                              } else {
                                _selectedDays.remove(day);
                              }
                              // Оновлюємо кубіт, якщо потрібно, або перед збереженням
                              _manageRoutineCubit.updateScheduledDays(List.from(_selectedDays));
                            });
                          },
                          selectedColor: Theme.of(context).primaryColorLight,
                        );
                      }).toList(),
                    ),

                    const SizedBox(height: 24),
                    Row(
                      mainAxisAlignment: MainAxisAlignment.spaceBetween,
                      children: [
                        Text('Exercises (${currentDisplayRoutine.exercises.length}):', style: Theme.of(context).textTheme.titleMedium),
                        ElevatedButton.icon(
                          icon: const Icon(Icons.add_circle_outline),
                          label: const Text('Add'),
                          onPressed: () async {
                            final RoutineExercise? newExercise = await showAddExerciseToRoutineDialog(context);
                            if (newExercise != null) {
                              _manageRoutineCubit.addExerciseToRoutine(newExercise);
                            }
                          },
                        ),
                      ],
                    ),
                    const SizedBox(height: 8),
                    if (currentDisplayRoutine.exercises.isEmpty)
                      const Padding(
                        padding: EdgeInsets.symmetric(vertical: 16.0),
                        child: Center(child: Text('No exercises added yet. Tap "Add" to begin.')),
                      )
                    else
                      ListView.builder(
                        shrinkWrap: true,
                        physics: const NeverScrollableScrollPhysics(), // Для списку всередині SingleChildScrollView
                        itemCount: currentDisplayRoutine.exercises.length,
                        itemBuilder: (ctx, index) {
                          return _buildExerciseItem(context, currentDisplayRoutine.exercises[index], index);
                        },
                      ),
                  ],
                ),
              ),
            );
          },
        ),
      ),
    );
  }
}
--------------------------------------------------
=== END OF FILE: lib/features/routines/presentation/screens/create_edit_routine_screen.dart ===


=== FILE: lib/features/routines/presentation/screens/user_routines_screen.dart ===
--------------------------------------------------
// lib/features/routines/presentation/screens/user_routines_screen.dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:firebase_auth/firebase_auth.dart';
import '../../../../core/domain/repositories/routine_repository.dart';
import '../cubit/user_routines_cubit.dart';
import '../widgets/routine_list_item.dart';
import 'create_edit_routine_screen.dart';
// import '../../../../core/domain/entities/routine.dart'; // <--- ВИДАЛЕНО

class UserRoutinesScreen extends StatelessWidget {
  const UserRoutinesScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return BlocProvider( // Змінено на один BlocProvider, оскільки ManageRoutineCubit тут не надається глобально
      create: (context) => UserRoutinesCubit(
        RepositoryProvider.of<RoutineRepository>(context),
        FirebaseAuth.instance,
      )..fetchUserRoutines(),
      child: Scaffold(
        appBar: AppBar(
          title: const Text('My Routines'),
        ),
        body: BlocConsumer<UserRoutinesCubit, UserRoutinesState>(
          listener: (context, state) {
            if (state is UserRoutinesError) {
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(content: Text('Error: ${state.message}'), backgroundColor: Colors.red),
              );
            }
          },
          builder: (context, state) {
            if (state is UserRoutinesLoading) {
              return const Center(child: CircularProgressIndicator());
            } else if (state is UserRoutinesLoaded) {
              if (state.routines.isEmpty) {
                return Center(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      const Icon(Icons.fitness_center, size: 60, color: Colors.grey),
                      const SizedBox(height: 16),
                      const Text(
                        'No routines yet.',
                        style: TextStyle(fontSize: 18, color: Colors.grey),
                      ),
                      const SizedBox(height: 8),
                      ElevatedButton.icon(
                        icon: const Icon(Icons.add),
                        label: const Text('Create Your First Routine'),
                        onPressed: () {
                          Navigator.of(context).push(MaterialPageRoute(
                            builder: (_) => const CreateEditRoutineScreen(),
                          ));
                        },
                      )
                    ],
                  ),
                );
              }
              return ListView.builder(
                itemCount: state.routines.length,
                itemBuilder: (context, index) {
                  final routine = state.routines[index];
                  // RoutineListItem тепер сам обробляє залежності для видалення,
                  // якщо RepositoryProvider доступний
                  return RoutineListItem(routine: routine);
                },
              );
            } else if (state is UserRoutinesError) {
              return Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    const Icon(Icons.error_outline, color: Colors.red, size: 48),
                    const SizedBox(height: 16),
                    Text('Failed to load routines: ${state.message}'),
                    const SizedBox(height: 16),
                    ElevatedButton(
                      onPressed: () => context.read<UserRoutinesCubit>().fetchUserRoutines(),
                      child: const Text('Retry'),
                    )
                  ],
                ),
              );
            }
            return const Center(child: Text('Press button to load routines or create one.'));
          },
        ),
        floatingActionButton: FloatingActionButton.extended(
          onPressed: () {
            Navigator.of(context).push(MaterialPageRoute(
              builder: (_) => const CreateEditRoutineScreen(),
            )).then((_) {
              // Опціонально: оновити список після повернення зі створення/редагування,
              // якщо ManageRoutineCubit не оновлює UserRoutinesCubit напряму.
              // context.read<UserRoutinesCubit>().fetchUserRoutines();
            });
          },
          icon: const Icon(Icons.add),
          label: const Text('New Routine'),
        ),
      ),
    );
  }
}
--------------------------------------------------
=== END OF FILE: lib/features/routines/presentation/screens/user_routines_screen.dart ===


=== FILE: lib/features/routines/presentation/widgets/add_exercise_to_routine_dialog.dart ===
--------------------------------------------------
// lib/features/routines/presentation/widgets/add_exercise_to_routine_dialog.dart
import 'package:flutter/material.dart';
// import 'package:flutter_bloc/flutter_bloc.dart'; // <--- ВИДАЛЕНО, якщо не використовується тут напряму
import '../../../../core/domain/entities/predefined_exercise.dart';
import '../../../../core/domain/entities/routine.dart';
import '../../../exercise_explorer/presentation/screens/exercise_explorer_screen.dart';


Future<RoutineExercise?> showAddExerciseToRoutineDialog(BuildContext context) async {
  final PredefinedExercise? selectedPredefinedExercise = await Navigator.of(context).push<PredefinedExercise>(
    MaterialPageRoute(
      builder: (_) => const ExerciseExplorerScreen(isSelectionMode: true), // <--- ВИПРАВЛЕНО
    ),
  );

  if (selectedPredefinedExercise == null) { // Перевірка mounted не потрібна перед pop
    return null;
  }

  // Подальший код залишається без змін, але переконайся, що `context` для `showDialog` є валідним.
  // Якщо `context` з попереднього екрану вже не валідний, це викличе помилку.
  // Але оскільки ми одразу викликаємо showDialog, він, ймовірно, буде валідним.
  // ignore: use_build_context_synchronously
  if (!context.mounted) return null; // Додаємо перевірку для безпеки

  return await showDialog<RoutineExercise>(
    context: context,
    builder: (dialogContext) {
      final setsController = TextEditingController(text: "3");
      final notesController = TextEditingController();
      final formKey = GlobalKey<FormState>();

      return AlertDialog(
        title: Text('Add "${selectedPredefinedExercise.name}"'),
        content: SingleChildScrollView(
          child: Form(
            key: formKey,
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: <Widget>[
                TextFormField(
                  controller: setsController,
                  decoration: const InputDecoration(labelText: 'Number of Sets'),
                  keyboardType: TextInputType.number,
                  validator: (value) {
                    if (value == null || value.isEmpty) return 'Cannot be empty';
                    final n = int.tryParse(value);
                    if (n == null || n <= 0) return 'Must be a positive number';
                    return null;
                  },
                ),
                const SizedBox(height: 16),
                TextFormField(
                  controller: notesController,
                  decoration: const InputDecoration(
                    labelText: 'Notes (optional)',
                    hintText: 'E.g., focus on form, pyramid sets'
                  ),
                  maxLines: 2,
                ),
              ],
            ),
          ),
        ),
        actions: <Widget>[
          TextButton(
            child: const Text('Cancel'),
            onPressed: () => Navigator.of(dialogContext).pop(null),
          ),
          ElevatedButton(
            child: const Text('Add Exercise'),
            onPressed: () {
              if (formKey.currentState!.validate()) {
                Navigator.of(dialogContext).pop(RoutineExercise(
                  predefinedExerciseId: selectedPredefinedExercise.id,
                  exerciseNameSnapshot: selectedPredefinedExercise.name,
                  numberOfSets: int.parse(setsController.text),
                  notes: notesController.text.trim().isNotEmpty ? notesController.text.trim() : null,
                ));
              }
            },
          ),
        ],
      );
    },
  );
}
--------------------------------------------------
=== END OF FILE: lib/features/routines/presentation/widgets/add_exercise_to_routine_dialog.dart ===


=== FILE: lib/features/routines/presentation/widgets/routine_list_item.dart ===
--------------------------------------------------
// lib/features/routines/presentation/widgets/routine_list_item.dart
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../../../core/domain/entities/routine.dart';
import '../../../../core/domain/repositories/routine_repository.dart'; // <--- ІМПОРТ ІНТЕРФЕЙСУ
import '../cubit/user_routines_cubit.dart';
// ManageRoutineCubit може не знадобитись тут, якщо UserRoutinesCubit обробляє видалення
// import '../cubit/manage_routine_cubit.dart'; 
import '../screens/create_edit_routine_screen.dart';
import 'dart:developer' as developer; // Для логування

class RoutineListItem extends StatelessWidget {
  final UserRoutine routine;

  const RoutineListItem({super.key, required this.routine});

  Future<void> _confirmDelete(BuildContext context) async {
    // Не використовуємо ManageRoutineCubit напряму тут, якщо UserRoutinesCubit має метод видалення.
    // final manageRoutineCubit = BlocProvider.of<ManageRoutineCubit>(context, listen: false);
    final userRoutinesCubit = BlocProvider.of<UserRoutinesCubit>(context, listen: false);

    final bool? confirmed = await showDialog<bool>(
      context: context,
      builder: (BuildContext dialogContext) {
        return AlertDialog(
          title: const Text('Confirm Delete'),
          content: Text('Are you sure you want to delete "${routine.name}"? This action cannot be undone.'),
          actions: <Widget>[
            TextButton(
              child: const Text('Cancel'),
              onPressed: () => Navigator.of(dialogContext).pop(false),
            ),
            TextButton(
              style: TextButton.styleFrom(foregroundColor: Colors.red),
              child: const Text('Delete'),
              onPressed: () => Navigator.of(dialogContext).pop(true),
            ),
          ],
        );
      },
    );

    if (confirmed == true) {
      // Ідеально: UserRoutinesCubit має метод для видалення
      // await userRoutinesCubit.deleteRoutine(routine.id);

      // Поточний варіант: видаляємо через репозиторій та оновлюємо список локально
      // Важливо: переконайся, що context ще валідний після await
      if (!context.mounted) return; 
      try {
        // Отримуємо репозиторій через RepositoryProvider
        final routineRepository = RepositoryProvider.of<RoutineRepository>(context);
        await routineRepository.deleteRoutine(routine.id);
        userRoutinesCubit.routineDeleted(routine.id); // Оновлюємо список локально

        if (context.mounted) { // Знову перевірка
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('Routine "${routine.name}" deleted.'), backgroundColor: Colors.green),
          );
        }
      } catch (e) {
        developer.log('Error deleting routine: $e', name: 'RoutineListItem');
        if (context.mounted) { // Перевірка
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('Error deleting routine: $e'), backgroundColor: Colors.red),
          );
        }
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Card(
      margin: const EdgeInsets.symmetric(horizontal: 12, vertical: 6),
      child: ListTile(
        title: Text(routine.name, style: const TextStyle(fontWeight: FontWeight.bold)),
        subtitle: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            if (routine.description != null && routine.description!.isNotEmpty)
              Padding(
                padding: const EdgeInsets.only(top: 4.0),
                child: Text(routine.description!, style: Theme.of(context).textTheme.bodySmall),
              ),
            Padding(
              padding: const EdgeInsets.only(top: 4.0),
              child: Text(
                '${routine.exercises.length} exercise(s)',
                style: Theme.of(context).textTheme.bodySmall?.copyWith(color: Colors.grey[600]),
              ),
            ),
            if (routine.scheduledDays.isNotEmpty)
              Padding(
                padding: const EdgeInsets.only(top: 4.0),
                child: Text(
                  'Scheduled: ${routine.scheduledDays.join(", ")}',
                  style: Theme.of(context).textTheme.bodySmall?.copyWith(color: Colors.grey[600]),
                ),
              ),
          ],
        ),
        isThreeLine: (routine.description != null && routine.description!.isNotEmpty) || routine.scheduledDays.isNotEmpty,
        trailing: PopupMenuButton<String>(
          onSelected: (value) {
            if (value == 'edit') {
              Navigator.of(context).push(MaterialPageRoute(
                builder: (_) => CreateEditRoutineScreen(routineToEdit: routine),
              ));
            } else if (value == 'delete') {
              _confirmDelete(context);
            }
          },
          itemBuilder: (BuildContext context) => <PopupMenuEntry<String>>[
            const PopupMenuItem<String>(
              value: 'edit',
              child: ListTile(leading: Icon(Icons.edit), title: Text('Edit')),
            ),
            const PopupMenuItem<String>(
              value: 'delete',
              child: ListTile(leading: Icon(Icons.delete, color: Colors.red), title: Text('Delete', style: TextStyle(color: Colors.red))),
            ),
          ],
        ),
        onTap: () {
          // TODO: Можливо, перехід на екран деталей рутини або початок тренування
          Navigator.of(context).push(MaterialPageRoute(
            builder: (_) => CreateEditRoutineScreen(routineToEdit: routine),
          ));
        },
      ),
    );
  }
}
--------------------------------------------------
=== END OF FILE: lib/features/routines/presentation/widgets/routine_list_item.dart ===


=== FILE: web/index.html ===
--------------------------------------------------
<!DOCTYPE html>
<html>
<head>
  <!--
    If you are serving your web app in a path other than the root, change the
    href value below to reflect the base path you are serving from.

    The path provided below has to start and end with a slash "/" in order for
    it to work correctly.

    For more details:
    * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base

    This is a placeholder for base href that will be replaced by the value of
    the `--base-href` argument provided to `flutter build`.
  -->
  <base href="$FLUTTER_BASE_HREF">

  <meta charset="UTF-8">
  <meta content="IE=Edge" http-equiv="X-UA-Compatible">
  <meta name="description" content="A new Flutter project.">

  <!-- iOS meta tags & icons -->
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="muscle_up">
  <link rel="apple-touch-icon" href="icons/Icon-192.png">

  <!-- Favicon -->
  <link rel="icon" type="image/png" href="favicon.png"/>

  <title>muscle_up</title>
  <link rel="manifest" href="manifest.json">
</head>
<body>
  <script src="flutter_bootstrap.js" async></script>
</body>
</html>

--------------------------------------------------
=== END OF FILE: web/index.html ===


=== FILE: web/manifest.json ===
--------------------------------------------------
{
    "name": "muscle_up",
    "short_name": "muscle_up",
    "start_url": ".",
    "display": "standalone",
    "background_color": "#0175C2",
    "theme_color": "#0175C2",
    "description": "A new Flutter project.",
    "orientation": "portrait-primary",
    "prefer_related_applications": false,
    "icons": [
        {
            "src": "icons/Icon-192.png",
            "sizes": "192x192",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-512.png",
            "sizes": "512x512",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-maskable-192.png",
            "sizes": "192x192",
            "type": "image/png",
            "purpose": "maskable"
        },
        {
            "src": "icons/Icon-maskable-512.png",
            "sizes": "512x512",
            "type": "image/png",
            "purpose": "maskable"
        }
    ]
}

--------------------------------------------------
=== END OF FILE: web/manifest.json ===


================================================================================
Snapshot Complete.
